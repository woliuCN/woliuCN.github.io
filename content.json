{"pages":[{"title":"前端内容整理","text":"作者: cn97 正在努力的人 以下整理的知识点是自己学习或者开发过程中积累的(当然有参考他人的博客文档等,不喜勿喷),学习中成长! JS相关 JavaScript [基础] JavaScript基础集合(一) [基础] JavaScript基础集合(二) ES6 [扩展] ES6知识点(一) [promise] ES6知识点(二) [class] ES6知识点(三) UI相关 CSS3 [基础] css需记点(一) [适配] css需记点(二) 预处理器 构建化工具 WebPack4 [概念] 配置文件及其相关概念 [配置] 基本配置(上) [配置] 基本配置(下) [进阶] 进阶使用(上) [进阶] 进阶使用(下) [优化] 相关的优化策略","link":"/bigweb/index.html"},{"title":"算法相关整理","text":"作者: cn97 正在努力的人 以下整理的知识点是自己学习或者开发过程中积累的(当然有参考他人的博客文档等,不喜勿喷),学习中成长! 设计模式 PS: 参考自《javascript设计模式》及查阅相关的博客资料 创建型模式 单例模式 工厂模式 抽象模式 结构型模式 适配器模式 代理模式 桥接模式 行为型模式 命令模式 策略模式 模板模式 责任链模式 备忘录模式 迭代器模式 观察者模式 面试算法题JavaScript实现 PS: 算法题是在牛客网上的《剑指offer》算法里面的,以及高级前端面试小程序的一些编程题，未来可能会在leetcode上练习…. 数组 对象数组转树形结构 两个数组交集 有序数组的中位数 寻找数是数字的数字之和的下标数组 旋转数组的最小数字 顺时针打印矩阵 链表 从尾到头打印链表 复杂链表的复制 树 重建二叉树 广度遍历实现深拷贝 深度遍历实现深拷贝 树的子结构 从上往下打印二叉树 二叉搜索树的后序遍历序列 二叉树中和为某值的路径 栈 栈的压入、弹出序列 其他 长整数相加 统计连续出现的字符及次数 跳台阶 二进制中1的个数","link":"/algorithm/index.html"}],"posts":[{"title":"ES6知识点(一)","text":"👇内容速览👇 一些新特性跟拓展 箭头函数特点及与普通函数的区别 Symbol数据类型 一些新特性跟拓展 const / Let 为了弥补js没有块级作用域的缺陷，引入了let块级变量声明。同时也引入了const 常量。其使用跟其他语言一样，只是需要注意以下以下几点： let跟const所声明的变量只在所在的代码块里面才有效，不存在变量提升，且不能重复声明，const在声明后必须初始化，否则会报错。 { var a=100; console.log(b); //出错！ const b=200; let c=50;}console.log(a); //100console.log(b); //出错！console.log(c); //出错！ ES6中，var、function声明的全局变量是作为window 的属性，而let、const、class声明的全局变量则是在Script对象上。 var a=100;const b=200;let c=50;console.log(window.a);//100console.log(window.b);//undefined//ps：具体可以通过谷歌浏览器开发者模式查看Scope可以看到 模板字符串 以往ES5输出字符串都是通过+号拼接的，十分麻烦，字符串还不支持换行。ES6里面的模板字符串是使用``来声明的，里面的变量则是用${item}来表示，跟那些模板引擎功能有点类似。 //ES5下$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!');//模板字符串$('#result').append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; //嵌入变量 are on sale!`);/*当模板字符串表示多行字符串的时候，所有的空格和缩进都会被保留到输出中，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。*/$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 扩展运算符跟双冒号运算符 ES6使用扩展运算符可以来展开数组或者对象，也可以用来给对象或者数组添加属性。而双冒号运算符是用来绑定函数的this指针的指向。 //扩展运算符展开数组/对象var a=[1,2,3];var b={name:\"cn\",age:12};var c={...b}console.log(...a); //1 2 3console.log(c); //{name: \"cn\", age: 12}//添加数组/对象属性var a=[1,2,3];var b=[4,5,...a];var c={name:\"cn\",age:12};var d={sex:\"man\",...c}console.log(b);//[4, 5, 1, 2, 3] console.log(d);//{sex: \"man\", name: \"cn\", age: 12}/*双冒号运算符::左边是一个对象，右边是一个函数，运算符自动将左边的对象（作为this）绑定到右边函数上类似于call/apply/bind的作用,得用babel转码才能实现*/foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); for…of、for…in和forEach、map区别 for-of：具有迭代器接口，可以遍历数组，类数组，set和map集和等等部署了迭代器接口的。不能遍历普通对象，可以中断。 for-in：遍历对象自身跟继承的可枚举的属性，即获取的是键值或者下标，可以中断。 forEach:只能遍历数组，不能中断，没有返回值。 map:只能遍历数组，不能中断，返回的是修改后的数组。 箭头函数特点及与普通函数的区别 在ES6之前，函数内部的this是指向谁调用了这个函数这个this就是指向谁的，当在一些回调函数里面，就可能出现想访问某些对象的属性的时候，this指向不是这个对象，导致访问不了，解决的方法一个是通过call,apply等方法改变this的指向，要么就一开始将this赋值给that,让作用域链来访问。可以通过使用箭头函数来解决这些繁琐的步骤。因为箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。即this是继承自父的执行上下文。话不多说，看代码就知道了。 var rules=1; var Empt={ rules:2, click:()=&gt;{ console.log(this.rules); }};function Button(){ this.rules=3; this.click=()=&gt;{ console.log(this.rules); };} Empt.click(); /* 1 箭头函数在创建时确定this的指向， 因为click箭头函数是作为对象字面量的属性定义， 对象字面量在全局定义，所以this 指向全局 */ var button=new Button(); button.click(); /*3 箭头函数作为新建对象的属性， Button函数this指向新建对象， 所以this指向新建对象 */ Symbol数据类型 在ES6引入的一种新的基本的数据类型，表示独一无二的的值，可以用来作为常量，或者定义私有变量。Symbol只能通过Symbol函数生成。因为它是一种基本的数据类型，所以在使用typeof检查的时候，返回的是’symbol’。且因为是独一无二的，所以比较两个symbol实例的时候，往往都是返回false。 作为对象属性名：用于保证不会出现同名的属性，还可以定义常量。注意！symbol值作为对象的属性名时，不能用点运算符，因为点号后面跟的是一个字符串，不是一个symbol值。 let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = 'Hello!';// 第二种写法let a = { [mySymbol]: 'Hello!' //常用}; 属性名的遍历：Symbol类型的key是不能通过Object.keys()或者for...in来枚举的，它未被包含在对象自身的属性名集合(property names)之中，只能用Object.getOwnPropertySymbols方法获取指定对象的所有Symbol属性名。或者用Reflect.ownKeys`方法返回所有类型的键名。 const obj = {};let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 全局的symbol：如果想共享同一个symbol，这时候就可以使用Symbol.for()方法。该方法跟Symbol方法类似，只不过这个方法接受一个参数，当有这样的一个Symbol值，则返回，否则则新建一个以该字符串为名称的Symbol值。","link":"/2020/03/12/es6/es6-base-1/"},{"title":"javaScript基础知识(上)","text":"👇内容速览👇 基本的数据类型及判断区别 闭包的一些问题 浅拷贝与深拷贝的区别跟实现 原型与原型对象 基本的数据类型及判断区别​ JS在ES6出现之前就只有以下几个数据类型：Number、String、Boolean、Undefined、Null、Function、Object。null只能自己手动赋值，而undefined当声明了变量没有赋值的时候，默认会赋值为undefined 。null也是对象。 基本数据类型：Number、String、Boolean、Undefined、Null、Symbol(ES6) 引用类型：Function、Object ​ 判断类型常用的方法是 typeof 操作符、instanceof操作符、Object.prototype.toString.call方法。三者的区别是： ① typeof：能判断基本的数据类型,除了null，在判别是否是Array的时候也不能判别出来，都会返回是object。 ② instanceof：不能判别基本的数据类型，但能判别对象（具体是哪个类），通过原型链判断。 ③ Object.prototype.toString.call：也是只能判别基本的数据类型，无法识别具体是哪个对象。 function A(){ return}var B = null;var c ;var D = new A();var E = { name:\"cn\",} //typeofconsole.log(typeof A) // functionconsole.log(typeof B) // objectconsole.log(typeof C) // undefinedconsole.log(typeof D) // objectconsole.log(typeof E) // object//instanceofconsole.log(A instanceof Function) // trueconsole.log(D instanceof A) // trueconsole.log(E instanceof A) // falseconsole.log(E instanceof Object) // true//Object.prototype.toString.call()console.log(Object.prototype.toString.call(A)) // [object Function]console.log(Object.prototype.toString.call(B)) // [object Null]console.log(Object.prototype.toString.call(c)) // [object Undefined]console.log(Object.prototype.toString.call(D)) // [object Object] 闭包的一些问题​ 何为闭包？闭包就是能突破作用域链，能读取到函数内部的变量，即如果一个函数会在父级返回后留住对父级作用域的连接的话，相应的闭包就会被创建。其实函数本身就是一个闭包！ //#1 将返回值赋值给另外一个全局变量，从而生成一个可以访问函数私有空间的函数。var a=\"global\";var F=function(){ var b=\"local\"; var N=function(){ var c=\"inner\"; return b; }; return N;};var inner=F();inner();//local 通过这样将N升级为全局变量，因为N可以访问F里面的变量，所以inner可以访问到b；//#2，声明一个全局占位符，实质是将N升级为全局变量。var inner;var F=function(){ var b=\"local\"; var N=function(){ return b; }; inner=N;}inner();// local 闭包好处就是能让我们访问到函数作用域里面的变量，可以用来封装私有变量。但有时候因为闭包也带来了一些不想要的结果。 //#3因为闭包可能出现的错误function F(){ var arr=[],i; for(i=0;i&lt;3;i++){ arr[i]=function(){ return i; }; }return arr;}var arr=F();//arr[0]() 3 arr[1]() 3 arr[2]() 3出现这个问题是因为这里创建了三个闭包，他们都指向了共同的变量i,它们拥有的是相关域在创建是的一个引用。//解决方法：1.立即执行函数 for(i=0;i&lt;3;i++){ arr[i]=(function (x){ return x; })(i); }return arr; }2.赋值给局部变量function F(){function binder(x){ return function(){ return x; };} var arr=[],i; for(i=0;i&lt;3;i++){ arr[i]=binder(i); }return arr;}//两种方法的实质都是将共同的变量变成自己的局部变量3. 使用ES6的 letfunction F(){ var arr=[]; for(let i=0;i&lt;3;i++){ arr[i]=function(){ return i; }; }return arr;} 浅拷贝与深拷贝的区别跟实现 对于引用类型，浅拷贝只是复制了对象在堆里面的引用地址，如果修改了其值，其他一起引用到这个对象的值也会受到影响。而如果想实现两个对象之间互不影响，就需要实现深拷贝，深拷贝是开辟了一个新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 浅拷贝就不多说了，深拷贝有以下几种方法： 如果只是拷贝一层对象的话就可以使用ES6提供的Object.assign() var obj1={a:1,b:2};var obj2=Object.assign({},obj1);obj1.a=4;console.log(obj2);//{a: 1, b: 2} 想简单粗暴就使用JSON实现 var obj1={a:10,b:{c:[1,2,3]}};var obj2=JSON.parse(JSON.stringify(obj1));obj2.b.c[0]=2;console.log(obj1);//{a:10,b:{c:[1,2,3]}}console.log(obj2);//{a:10,b:{c:[2,2,3]}} 最直接就是递归实现 function deepCopy(p,c){ c=c||{}; for(var i in p){ if(typeof p[i]==='object'){ //数组也得深拷贝一份 c[i]=Array.isArray(p[i])?p[i].splice():{}; deepcopy(p[i],c[i]); }else{ c[i]=p[i]; } } return c} lodash库提供的方法 var _=require('lodash');var obj1={a:10,b:{c:[1,2,3]}};var obj2=_.cloneDeep(obj); 原型与原型对象​ 原型（proto）跟原型对象（prototype）一开始小编也是晕晕，搞了大半天才明白是什么。个人习惯这样叫比较容易分清楚。其实归咎就是一句话，原型是每个对象都会有的属性，它是一个隐式指针，指向了创建这个对象的构造器函数的原型对象。原型对象就只有函数才拥有。又因为函数也是对象（也是通过new Function出来的，我们平时写的都是函数字面量），所以它本身拥有了两个属性，即上面的原型跟原型对象。 function A(){ this.name=\"cn\"; this.age=\"18\";}var obj=new A();console.log(obj.__proto__==A.prototype);//true 这时候就得插个题外话啦，在ES6之前，是没有class这个语法糖的，所有的对象都是通过构造器函数创建的。 //new 一个对象的过程function A(){ this.name=\"cn\"; this.age=\"18\";}var obj=new A();当new 一个实例对象的时候，其实大致发生了这样的事情：1.首先创建了一个空对象 var obj={};2.将这个对象的原型指向这个构造器函数的原型对象，实现共享方法的继承obj.__proto__=A.prototype;3.使用call/apply将构造器函数里面的this指向改变成为objA.call(obj)4.构造器函数最终返回this，就是我们的new的实例对象 ​ 构造器函数里面的属性是实例的属性，是属于每个实例对象的，而每个实例对象都会有共有的属性，那就是原型对象上的。 function Gadget(name,color){ this.name=name; this.color=color;}Gadget.prototype.pirce=100;var newtoy=new Gadget('cn','blue');newtoy.name //\"cn\"newtoy.price //100/*当我们访问price属性的时候，JavaScript引擎首先查询newtoy对象的所有属性，如果找到，就返回，但如果找不到，就会去查询用于创建当前对象的构造器函数的原型，即访问newtoy.constructor.prototype 找到就返回。再找不到就顺者原型链找下去，直到找到Object*/","link":"/2020/03/09/javascript/javaScript-base-1/"},{"title":"ES6知识点(二)","text":"👇内容速览👇 Set、Map数据结构 Proxy(代理器) Promise对象 Set、Map数据结构 Set ​学过Java的话就会对这个数据结构很熟悉。它类似于数组，但是区别在于它的成员值只能是唯一的，也就是说，里面是没有重复的值。跟其他数据类型一样，都是由构造器函数Set本身来new生成相应的实例。它可以接受一个数组作为参数，所以可以用来进行数组的去重工作。 注意：Set没有键名，只有键值。或者说它的键值与键名是同一个！ //构造一个Set实例，接受一个数组作为参数const set=new Set([1,2,3,4]);//可以被for...of遍历。可以看到键值与键名是一样的for(let item of set.entries()){ console.log(item)}// [1,1] [2,2] [3,3] [4,4] Set 的四个操作方法 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 Set 的四个遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 WeakSet 与Set类似，但正如其名一样，它只是Set的弱类型，且成员只能是对象，对成员对象的引用是弱引用。弱引用就是对值的引用的不计入垃圾回收机制的引用次数的，很可能在某时刻被垃圾回收机制给回收掉。所以不能被遍历，因为值不知道什么时候会被回收了。但是因为这个特性，可以用来存放一组临时的对象，以及存放对象的相关信息，只要外部的引用消失，WeakSet对这个对象的引用也自动消失。以此减少内存泄漏。 const ws = new WeakSet();var a={dom:document.getElementById('root'),name:'cn'}ws.add(a);console.log(ws.has(a));//truea = nullconsole.log(ws.has(a));//false Map Map跟对象很类似，但是传统的对象的键名只能是字符串，这里的Map的键名可以是任何的类型，包括对象。同样的，也是通过构造器函数来初始化实例，可以接受一个参数，任何具有迭代器接口，且成员是一个双元素的数组的数据结构，都可以作为参数。 const map=new Map([['name','cn'],['age','20']]);console.log(map.size); //2console.log(map.get('name'));//cn//接受数组为参数，实际是执行了一下的代码var item=[['name','cn'],['age','20']];const map=new Map();item.forEach(([key,value])=&gt;{ map.set(key,value);}) 注意：同一个值的不同对象是被视为不同的键的。 Map的属性和方法 size 属性 返回成员总数。 set(key, value) 设值 get(key) 获取值 has(key) 查询 delete(key) 删除 clear() 清除所有成员 遍历方法类同Set WeakMap 与Map类似，但只接受对象作为键，键名对对象的引用是弱引用，其引用对象可以被垃圾回收，不能遍历。可以用来保存DOM节点。即如果想为对象添加相应的数据或者描述，又不想干扰垃圾回收机制，Map是很好的选择。 const wm = new WeakMap();const element = document.getElementById('root');wm.set(element, 'information');/*此时如果消除element的引用，则所占的内存将会被回收，Weakmap 保存的这个键值对，也会自动消失。*/-------------------------------------------------/*ps：下面是用 node模拟的一个环境,搜了不少都是说heapUsed值才是判断内存是否泄漏的标准，但是我这里的键值是一个数组，它的存储空间是在栈里面而不是堆，所以感觉看rss的占用可能是比较对吧（个人猜想，因为heapUsed的值就按照所想的值的顺序出现，有正确的 观点的欢迎在评论指出................）*/PS D:\\react\\server&gt; node --expose-gc&gt; global.gc();undefined&gt; process.memoryUsage();{ rss: 22376448, //所有内存占用 heapTotal: 6635520,//堆占用的内存 包括用到跟没用到的 heapUsed: 4548648,//用到的堆 external: 9625 }// V8引擎内部C++对象占用的内存&gt; let wm = new WeakMap();undefined&gt; let b = new Object();undefined&gt; global.gc();undefined&gt; process.memoryUsage();{ rss: 22044672, heapTotal: 7684096, heapUsed: 4830024, external: 8716 }&gt; wm.set(b, new Array(5*1024*1024));WeakMap {}&gt; global.gc();undefined&gt; process.memoryUsage();{ rss: 64049152, //set之后，内存占用明显变大 heapTotal: 49639424, heapUsed: 46702528, external: 8619 }&gt; b=null; //清除外部引用null&gt; global.gc();undefined&gt; process.memoryUsage();{ rss: 22102016, //内存大小恢复跟之前开始的差不多大小的值 heapTotal: 7684096, heapUsed: 4757064, external: 8682 }&gt; Proxy(代理器) ES6引入了proxy对象，用来在访问目标对象之前进行一些拦截操作，可以对外界的访问进行过滤跟改写。同样的，它也是有相应的构造器函数来构建实例。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象进行操作。 var proxy=new Proxy(target,handler)//其中target表示要拦截的对象，handler则是定义拦截的行为，也是一个对象Ps:如果handler为一个空对象，则w没有拦截效果，访问proxy就是访问target本身//对象的读取操作,使用get方法var person={ name:'cn'}var proxy=new Proxy(person,{ get:function (target,property){ if(property in target ){ return target[property] }else{ throw new Error('没有这个参数') } }});proxy.name //cnproxy.age //抛出异常 Proxy支持的拦截操作一共有13种，具体可以去看阮一峰大佬的文档👇 http://es6.ruanyifeng.com/#docs/proxy#Proxy Promise对象 以往的异步编程，往往都是通过事件+回调函数来实现，但是当回调嵌套很多层的时候，其代码的可读性跟维护难度都会大大增加，进而出现“回调地狱”这种情况。而promise对象，表示一个异步操作的最终状态(成功或者失败),可以将异步操作用“同步”的形式表示出来，从而解决了“回调地狱的问题”。 promise有三种状态：pending(进行中)、resolved-fulfilled(已成功)、 rejected(已失败),对象的状态不受外界影响。所以Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 基本用法 const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); }});promise.then((data)=&gt;{ console.log(data)}).catch(err=&gt;{ console.log(err)})/*如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的异常是不会传递到外层代码的。所以一般要实现catch方法，catch方法会返回一个promise对象，所以依旧可以调用then方法Promise 对象的错误具有“冒泡”性质，一直向后传递，直到被捕获为止。错误总是会被下一个catch语句捕获。所以catch一般写在最后*/ Promise.all() 将多个promise实例包装成一个新的promise对象，新的promise对象只有等到参数成员里面的所有成员的状态是fulfilled，它才会是fulfilled。如果成员中有定义了自己的catch方法，那么新的Promise实例的catch方法不会被触发 var promise1=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 2000);});var promise2=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 0);});Promise.all([promise1,promise2]).then((data)=&gt;{ console.log(data);})// 结果是两秒后输出[ 'promise1', 'promise1' ]var promise1=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 2000);});var promise2=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { reject(); }, 0);});Promise.all([promise1,promise2]).then((data)=&gt;{ console.log(data);}).catch(()=&gt;{ console.log(\"promise_all\"); })// promise_allvar promise1=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 2000);});var promise2=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { reject(); }, 1000);}).catch(()=&gt;{ console.log(\"promise_2\");})//这里的promise2实际是catch后返回的新的promise实例Promise.all([promise1,promise2]).then((data)=&gt;{ console.log(data);}).catch(()=&gt;{ console.log(\"promise_all\");})/*输出 promise_2 [ 'promise1', undefined ]为什么呢?因为p2会先reject,reject后被自身的catch捕获，catch会返回新的promise，这个在catch执行完成后会变成resolved,所以最后会调用promise.all的then方法*/ Promise.race 该方法与Promise.all()方法类似，只不过是只要有一个的状态发生改变，新的实例的对象也就会跟着改变。 var promise1=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 2000);});var promise2=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise2\"); }, 1000);})Promise.race([promise1,promise2]).then((data)=&gt;{ console.log(data);}).catch(()=&gt;{ console.log(\"promise_all\");})//promise2 Promise.resolve 参数是一个Promise对象，将不做任何改变 其他参数，则直接转换，状态为resolved。常用来生成一个状态为fulfilled的promise实例 const p = Promise.resolve('Hello');p.then(function (s){ console.log(s)});// Hello Promise.reject 返回的是一个promise实例，状态是rejected,常用来生成一个状态为rejected的promise实例 const p = Promise.reject('error');//等同于const p = new Promise((resolve, reject) =&gt; reject('error'))p.catch((err)=&gt;{ console.log(err);})//error","link":"/2020/03/12/es6/es6-base-2/"},{"title":"ES6知识点(三)","text":"👇内容速览👇 Generator函数 async/await Class语法 Generator函数 基本语法 与promise对象一样，同样是为了异步编程。ES6提出了Generator函数，Generator函数是一个状态机，内部封装了多个状态，返回结果是一个迭代器(Iterator)对象。与普通函数的区别在于function声明与函数名之间多了个星号。且函数内部能使用yield关键字（普通函数使用将报错）。🙋‍个例子 function * exampleGenerator(){ yield 'hello'; yield 'world'; return \"end\"}var g= exampleGenerator();//里面有三个状态,分别对应三个关键字后面的字符串 调用函数后，并不会执行，因为其返回的不是一个值，而是一个Iterator对象，必须是调用这个对象的next方法，将内部的指针从函数头部或者是上一次停留的地方向下移动，遇到yield/return就会停止下来，返回后面跟随的值，然后挂起，下次next再重复上面的步骤。 console.log(g.next());/*{value: \"hello\", done: false}value表示当前的值，done 则表示遍历是否结束*/console.log(g.next());//{value: \"world\", done: false}console.log(g.next());//{value: \"end\", done: true} 带参数的next方法 因为yield方法并没有返回值，当我们下一个yield需要上参数的时候，这时候就只能通过next方法传参进去。next里面的参数表示的是上一个yield表达式的返回值,如果在另外一个表达式里面，必须放在圆括号里面。这个也是后面async函数内部实现的原理步骤之一。 function * exampleGenerator(x){ var y = yield (x+1) ; var z = yield (y*2); return x+y+z;}var g= exampleGenerator(2);console.log(g.next());//2+1=3 {value: 3, done: false}console.log(g.next(4));//4*2=8 {value: 8, done: false}console.log(g.next(5));//2+4+5=11 {value: 11, done: true}-----------------------------------//再看一个例子，会更加明白function * exampleGenerator(x){ var y = 2 * (yield(x+1) ); var z = yield (y*2); return x+y+z;}var g= exampleGenerator(2);console.log(g.next());// 2+1=3console.log(g.next(4));// 2*4*2=16console.log(g.next(5));// 2+2*4+5=15 自动遍历内部的值：使用for…of循环 因为for…of循环能遍历具有Iterator接口的，而generator函数返回的刚好是一个迭代器对象。无需调用next方法，适合那些不用传参计算的情况。注意：return 返回的值不包括在里面 function * exampleGenerator(){ yield 'hello'; yield 'world'; return \"end\"}var g= exampleGenerator();for(let item of g){ console.log(item);}// hello world yield* yield 语句后面如果想执行一个generator,使用yield*表达式。 function * firstGenerator(){ yield 'cn'; yield 'emmmm';}function * secondGenerator(){ yield 'hello'; yield 'world'; yield *firstGenerator() ;}var g= secondGenerator();for(let item of g){ console.log(item);}// hello world cn emmmm throw方法 定义在原型对象上的throw方法，每个由generator函数返回的迭代器对象，都会拥有，可以在函数体外部调用，用来抛出错误，优先被函数内部的try…catch捕获，如果内部没有try…catch的话，就被外部的try…catch捕获。如果内外都没有的话，就直接报错，中断执行。 注：g.throw与throw互不影响！ 被内部捕获的话，会顺带执行下一个yield表达式，且不会影响下面的执行,如果不是被内部捕获的，就不会继续执行下去，即使在外面有try…catch块。 #内部捕获function * exampleGenerator(){ try{ yield 'hello'; }catch(e){ console.log(e); } yield 'world'; yield 'emmm';}var g= exampleGenerator();console.log(g.next());console.log(g.throw('错误'));console.log(g.next());/*{value: \"hello\", done: false} 错误 {value: \"world\", done: false} {value: \"emmm\", done: false}*/#外部捕获function * exampleGenerator(){ yield 'hello'; yield 'world'; yield 'emmm';}var g= exampleGenerator(); console.log(g.next()); //hellotry{g.throw('错误')}catch(e){ console.log(e); //错误}console.log(g.next());//undefined async/await之前讲过的异步编程的方法，回调函数，嵌套多层的时候“回调地狱”问题难以处理。所以才有了Promise对象。但是当嵌套很多层的时候，一堆的return、then语句写到迷茫，代码可读性跟简洁性就会降低。而async/await则是用同步的思想来处理异步的操作，代码的可读性跟简洁性就会大大提高，它其实是由generator跟promise结合而成的。 用法 可以看成是generator函数的语法糖，将(*)替换成async，将yield 替换成await，且是自执行的，await后面跟的是一个promise对象或者其他类型的值都行，await有返回值，返回值就是后面跟着的那个。整个函数返回值也是一个promise对象。 console.log('start');var p1=new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(1); },1000)})var p2=(x)=&gt;{ return new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(x); },1000) })}var a=async function(){ var a1= await p1; var a2= await p2(a1) return a1+a2}()a.then((data)=&gt;{ console.log(data);})console.log('end');// start end 2 由此可以看出异步函数虽然以同步的形式写的，但是并不会阻塞住，实质是遇到await的时候，会先让出执行栈，等到异步操作完成(这里就是promise对象resolve的时候)，再执行下面的操作，且可以将其返回值作为下一个异步操作的参数（这个在很多情况下很有用）。 通常情况下，如果await后面的promise对象变成了reject状态的话，整个函数将会中断执行。如果想不影响下面执行的话，就得在内部进行异常捕获。 var a=async function(){ try { await Promise.reject('hhh'); } catch (error) { console.log(error); } var a1= await 'hehehe' return a1}()a.then((data)=&gt;{ console.log(data);})//hhh hehehe 实现原理 前面说到，async 可以由generator函数+promise对象来实现，👇下面是实现思路 function getCountry(url){ return new Promise((resolve,reject)=&gt;{ resolve(\"中国\"); })}function getCity(country){ return new Promise((resolve,reject)=&gt;{ resolve(\"潮州\"); })}function getProvince(country){ return new Promise((resolve,reject)=&gt;{ resolve(\"广东省\"); })}// 定义一个generator函数function * gen(){ //getCountry是一个异步操作 const country = yield getCountry(\"url\"); const province = yield getProvince (country); const city = yield getCity(province); return city}//自定义async函数function async (generator){ //返回一个迭代器对象 var interator = generator(); return new Promise((resolve,reject)=&gt;{ function handle (interatorResult){ console.log(interatorResult); /* 获取当前值 { value: Promise { '中国' }, done: false } { value: Promise { '广东省' }, done: false } { value: Promise { '潮州' }, done: false } { value: '潮州', done: true } */ const value=interatorResult.value; //到最后一个的时候就直接resolve出去 if(interatorResult.done){resolve(value)} if(value instanceof Promise){ value.then((res)=&gt;{ //递归调用，res作为上一个yield的返回值传递下去 handle(interator.next(res)) }).catch(e=&gt;{interator.throw(e)}) } } //启动调用 handle(interator.next()); })} async(gen).then(val=&gt;{ console.log(val);//潮州 }) Class语法在ES6之前，是没有class类与extends继承的概念的，所有的对象都是通过构造器函数创建的，继承也是通过原型链来实现，为了简便语法，更加面向对象，ES6引入了这两个“语法糖”。 Class 在类里面，实例的属性得显示的定义在this上。否则将被认为要定义在原型上，与ES5一样，实例的原型会指向类的原型对象上。 class Man { constructor(name){ this.name=name } getName(){ console.log(this.name); }}var man=new Man('cn');console.log(man.hasOwnProperty('name'));/* true 构造器里面定义的属性是在实例上的*/console.log(man.getName===Man.prototype.getName);console.log(man.hasOwnProperty('getName'));console.log(man.__proto__.hasOwnProperty('getName'));/* true false true 类里面声明的方法都是定义在类的原型对象上的。 实例的__proto__指向的是Class.prototype*/ getter/setter class里面也可以对对象属性的读取跟设置进行拦截修改，途径就是get / set 方法 class Man { constructor(){ } get name(){ return 'cn1997' } set name(value){ console.log('setter '+value); }}var man=new Man();man.name='cn'; // setter cnconsole.log(man.name); // cn1997 其他 class 内部方法的this默认是指向类的实例的，类不必函数，不存在变量提升，即不能在类声明之前创建一个实例对象。class.name属性将会返回类名…… 继承 ES5：对比ES5的继承一般都是寄生组合式，即实例属性使用构造器继承，而方法使用原型继承方法。 function A(){ this.name='a'}A.prototype.getName=function(){ return this.name;}function B(){ A.apply(this); //继承属性 this.age='12'}B.prototype=new A();console.log(B.portotype._proto_===A.prototype) //trueconsole.log(B._proto_===A)//false ES6的继承，根据阮一峰大佬的话来说，ES6的继承分两条链，一条是原型链，一条是原型对象的链。 子类的proto属性，表示构造器的继承，指向父类。跟ES5的不同之处。 子类的prototype属性的proto，表示方法的继承，指向父类的prototype，这一点与ES5的一致。 实例的指向就很明确了，根据所构造的类的关系去找。 class A{ constructor(){ this.name='cn'; } getName(){ return this.name; }}class B extends A{ constructor(){ super() }}var a=new A();var b=new B();console.log(a.__proto__===b.__proto__)//falseconsole.log(a.__proto__===b.__proto__.__proto__);//trueconsole.log(B.prototype.__proto__===A.prototype) //trueconsole.log(B.__proto__===A)//true 区别来了，ES6的继承，子类必须在构造器函数里面调用super方法，因为子类的this对象，必须先通过父类的构造函数塑造，得到父类的实例属性跟实例方法，而后在将其加工，加上子类的实例属性跟方法，总而言之，不调用super方法，子类得不到this对象。而ES5的继承，是先通过创建了一个子类的实例对象this，再将父类的方法跟属性添加到this上( A.apply(this) )。可以这样理解☞，之前我们知道new 一个实例的过程，先创建一个空对象，而ES6可能是创建的是一个父类的对象，所以super可能就是创建的一个父类的对象，再进行后续的操作….","link":"/2020/03/12/es6/es6-base-3/"},{"title":"抽象工厂模式","text":"一、抽象工厂模式及其用途抽象工厂模式，其实就是在工厂模式的基础上，对工厂类再次抽象封装，产生一个超级工厂类。这个超级工厂类同时可以用一个抽象工厂类对子类工厂进行约束，超级工厂创建的是一个类簇，类簇里面才是相应的对象实例。 二、代码实现抽象工厂类制定约束构建一个抽象工厂类来对工厂类的实现进行相应的约束 class AbstractFactory{ getPerson(){ throw new Error(\"子类请实现接口\"); } getAnimal(){ throw new Error(\"子类请实现接口\"); }} 创建实体类class Dog { name(){ console.log('狗'); }}class Cat { name(){ console.log('猫'); }}class Male { name(){ console.log('男人'); }}class Female { name(){ console.log('女人'); }} 创建各自的工厂类跟之前工厂类一样创造工厂来产出相应的实例，只不过这时候的工厂会受到抽象工厂类的约束 class PersonFactory extends AbstractFactory{ getPerson(person){ switch(person){ case:'male' return new Male(); case:'female' return new Female(); default: break; } } getAnimal(){ return null; }}class AminalFactory extends AbstractFactory{ getAnimal(name){ name=name.toLocaleLowerCase(); switch(name){ case:'dog' return new Dog(); case:'cat' return new Cat(); default: break; } } getPerson(){ return null; }} 超级工厂类的实现//超级工厂类，生产对应的工厂类簇class Factory { constructor(choice){ choice=choice.toLocaleLowerCase(); switch(choice){ case:'person' return new PersonFactory(); case:'aminal' return new AminalFactory(); default: throw TypeError(\"class name wrong\"); } }}//创建person工厂类const personFactory =new Factory(\"person\");//创建male实例const male=personFactory.getPerson(\"male\");male.name()//'男人'","link":"/2020/03/13/pattern/abstractFactory-pattern/"},{"title":"javaScript基础知识(下)","text":"👇内容速览👇 JS的运行机制（浏览器） ES5的继承的实现 浏览器对象与文档对象 JS的运行机制（浏览器） JavaScript是单线程语言，也只能是单线程，因为JS的用途就是与用户交互，假设同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程在删除这个节点，此时浏览器就不知道以哪个线程为准。因此它只有一个调用堆栈（call stack），一次只能做一件事情。例如进入一个函数，则把函数放在堆栈的顶部，如果一个函数返回，则弹出。因为是单线程，所以只能顺序执行，但如果执行的任务耗时间过长，则会产生很多不好的影响，解决这个的方法就是它本身的事件循环机制跟其回调队列。JavaScript 事件循环机制分为浏览器和 Node 事件循环机制。今天先讲浏览器的。 ​ 讲事件循环之前先讲一下浏览器的内核：浏览器内核是多线程，在内核控制下各个线程相互配合保持同步，有以下的常驻线程： GUI渲染线程：负责页面的渲染，解析HTML、 CSS,构建DOM树，布局跟绘制。当界面需要回流重绘的时候就会执行该线程，同时这个线程是跟JS引擎线程互斥的。 JS引擎线程：顾名思义，这个线程是来解析JS代码的，同时也是负责执行需要执行的事件，例如定时器结束、异步成功的回调函数，将依此进入事件队列，等待这个线程的执行。 定时器触发线程：负责执行定时器一类的函数的线程。计数完毕后，事件触发线程就会将计数完毕的事件加入事件队列（这个事件就是触发回调函数的事件），等待JS引擎线程执行。 事件触发线程：负责将准备好的事件交给JS线程执行，例如：定时器函数计数完毕，异步请求成功触发回调函数，用户触发点击事件….. 异步HTTP请求线程:负责异步请求的线程，当异步执行完毕后触发回调函数，事件触发将相应的事件加入任务队列。 事件循环：将执行的任务分成异步跟同步任务。一同步任务跟异步任务进入不同的执行场所。同步进入主线程执行，异步的任务进入Event table 并注册其回调函数。当任务执行完成后，Event table将这个函数移入Event queue（回调队列）——（即在这个队列中放置一个事件）,等到主线程内的任务执行完毕为空，则去Event queue读取相应事件，将对应的函数放入主线程执行。 不断重复，就是事件循环。 “任务队列/回调队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。就是上面事件触发线程跟JS线程之间的交流了。 “任务队列/回调队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 异步任务的区别：但是异步任务来说，应该也有执行的先后吧，有人会这样问。确实，当同时有异步任务一起执行的时候，到底是谁先谁后。这个时候就得说一下宏任务跟微任务了。注：宏任务队列能有多个，微任务队列就只有一个 宏任务：包括整体的同步代码，setTimeout, setInterval，IO ，各种事件等。 微任务：Promise process.nexTick(目前就两个)。 此时事件的循环顺序是，进入整体代码（第一个宏任务）开始第一次循环。遇到宏任务，将其回调函数分发到宏任务Event queue。遇到微任务，将其回调函数分发到微任务Event queue。而后执行这第一个宏任务里面的所有微任务（即执行异步任务的回调队列）。而后再找下一个宏任务，反复循环。🙋‍举个简单的栗子： setTimeout(function() { console.log('setTimeout');})new Promise(function(resolve) { console.log('promise'); resolve();}).then(function() { console.log('then');})console.log('console');//输出结果 promise console then setTimeout/*这段代码作为宏任务，进入主线程。先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。遇到console.log(console)，立即执行。整体代码script作为第一个宏任务执行结束，看看有哪些微任务？发现了then在微任务Event Queue里面，执行。ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。结束。*/ ES5继承的实现JavaScript的继承与其他语言不同，它是通过原型链来实现的。之前已经讲过，一个实例对象的原型(proto)会指向创建这个实例的构造器函数的原型对象(prototype)。当我们访问属性的时候，会先找实例对象本身的属性，如果找不到会往原型链上找。就是通过这种思想来实现继承的。 类式继承：最简单的继承，将父类的实例赋值给子类的原型。缺点是如果父类的属性是引用类型的话，就会出现一些意想不到的情况。(改一个而动全部)。 function Shape(){ this.books=[\"JS\",\"CSS\"];}function TwDshape(){}TwDshape.prototype=new Shape(); TwDshape.prototype.constructor=TwDshape;var my=new TwDshape();var your=new TwDshape();console.log(my.books);// [\"JS\", \"CSS\"]your.books.push(\"HTML\");console.log(my.books);// [\"JS\", \"CSS\", \"HTML\"] 构造函数继承：利用实例对象之间互不影响的特性，将父类的构造器函数在子类构造器函数里面执行一遍，实现继承。缺点是父类的原型对象上的属性不能获取到。因为没有建立原型链。 function Shape(){ this.books=[\"JS\",\"CSS\"];}function TwDshape(){ Shape.call(this);//利用call/apply改变this指向}var my=new TwDshape();var your=new TwDshape();console.log(my.books);// [\"JS\", \"CSS\"]your.books.push(\"HTML\");console.log(my.books);// [\"JS\", \"CSS\"] 寄生组合型继承：构造函数继承与原型的继承的结合（原型对象继承是在类式继承的基础上改进）。结合两种继承方式的优点。 //原型对象继承function inheritObject(parent){ var F=function(){}; //加了一个空中介函数,这样子的好处是直接继承了父级的原型对象的属性 F.prototype=parent.prototype; return new F(); //返回的是空中介函数的实例，不是之前的父类的实例，节省了构造父类实例的步骤}//寄生组合型function Shape(){ this.books=[\"JS\",\"CSS\"];}Shape.prototype.toString=function(){ return this.books; }function TwDshape(){ Shape.call(this);//利用call/apply改变this指向}var p=inheritObject(Shape); //返回的是F实例TwDshape.prototype=p;TwDshape.prototype.constructor=TwDshape; //修正因为重写子类原型对象而导致的constructor被修改var my=new TwDshape();var your=new TwDshape();console.log(my.toString());// [\"JS\", \"CSS\"]your.books.push(\"HTML\");console.log(your.toString());//[\"JS\", \"CSS\", \"HTML\"]console.log(my.toString());// [\"JS\", \"CSS\"] 浏览器对象与文档对象 浏览器对象BOM：页面以外事物拥有的对象。包括window，Navigator,Screen,History, Location。最主要的是window,它包含了对其他几个对象的引用，也有对document对象的引用。 window：浏览器窗口。所有全局 JavaScript 对象，函数和变量自动成为 window 对象的成员。 Navigator：包含了有关访问者的信息。如浏览器应用程序的名称（appName）、是否已启用cookie、浏览器是否在线。 Screen：包含有关客户端显示屏的信息。 History:包含用户访问过的URL。 Location:包含当前有关URL的信息。 DOM：文档对象模型，在HTML DOM中，每个部分都是节点，文挡（document）本身就是文档节点，所有的html元素（element/标签）是元素节点，所有的元素的属性是属性节点，元素的文本是文本节点，注释是注释节点。引用一张图： DOM节点的操作属性跟方法。 1.访问/获取节点document.getElementById(id); //返回对拥有指定id的第一个对象进行访问document.getElementsByName(name); //返回带有指定名称的节点集合 document.getElementsByTagName(tagname); //返回带有指定标签名的对象集合 document.getElementsByClassName(classname); //返回带有指定class名称的对象集合 2.创建节点/属性document.createElement() //创建一个节点document.createAttribute() //对某个节点创建属性document.createTextNode() // 创建文本节点3.添加节点document.inseretBefore(newNode,referenceNode) // 在某个节点前插入节点parentNode.appendChild(newNode) // 给某个节点添加子节点4.复制节点cloneNode（true/false） //复制某个节点5.删除节点parentNode.removeChild（node） // 删除某个节点的子节点6.属性操作getAttribute（name） // 通过属性名称获取某个节点属性的值setAttribute（name,value） // 修改某个节点属性的值removeAttribute（name） //删除某个属性7.查找节点.firstChild // 获取第一个子节点.firstElementChild // 获取第一个元素节点.lastChild // 获取最后一个子节点.lastElementChild // 获取最后一个元素节点.childNodes // 获取节点的所有子节点8.获取相邻的节点.previousSibling //获取已知节点的相邻的上一个节点.previousElementSibling //获取已知节点的相邻的上一个元素节点.nextSibling //获取已知节点的下一个节点.nextElementSibling //获取已知节点的下一个元素节点9.获取父节点.parentNode //得到已知节点的父节点10.替换节点.replace（ newNode，oldNode） //从父节点中用新节点提换旧节点11.修改文本节点appendData（data） //在文本节点后添加节点deleteData（start,length） //从start处删除length字符insertData（start，data） //在start处插入字符，start的开始值是0replaceData（start，length，data）//在start处用data替换length个字符12.nodeName 节点的名称。元素节点的 nodeName 等同于标签名属性节点的 nodeName 是属性名称文本节点的 nodeName 总是 #text文档节点的 nodeName 总是 #document13.nodeValue 节点的值元素节点的 nodeValue 是 null文本节点的 nodeValue 是文本文本属性节点的 nodeValue 是属性值-------------------------------------------------------------------//例子&lt;body&gt; &lt;div id=\"root\"&gt; &lt;a href=\"#\" id=\"a\"&gt;&lt;/a&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; var myTitle = document.getElementById(\"root\").childNodesconsole.log(myTitle)//NodeList(5) [text, a#a, text, p, text] 注：换行在浏览器里面是当成text节点","link":"/2020/03/09/javascript/javaScript-base-2/"},{"title":"代理模式","text":"一、代理模式及其用途代理模式，给原对象提供一个代理对象，代理对象拥有原对象的引用，可以通过访问这个代理对象来实现执行原对象的相关操作，进而能避免对原对象的直接访问。举个例子：如平常我们买车买房，自己亲自去找车主房主是不现实的，通常做法就是去找中介，代理对象就了类似与中介，拉起两者之间的桥梁。代理有虚拟代理跟保护代理，保护代理的话可以在代理中直接拒绝对真实对象的访问，而虚拟代理的话可以延迟访问到真正需要的时候，节省程序开销。所以优点是高度解耦，对象保护，缺点的话就是添加的代理对象，可能会开销增大。 二、代码实现/*----------------------------------------------------------------------保护代理*/ var Fans = { flower(){ Agent.reception(\"刀片\"); } } var Agent = { reception:function(gift){ console.log(\"粉丝送的:\"+gift); //粉丝送的:刀片 if(gift != \"花\"){ star.reception(\"花\"); } } } var star = { reception:function(gift){ console.log(\"收到粉丝的:\"+gift); //收到粉丝的:花 } } Fans.flower();/*----------------------------------------------------------------------虚拟代理*///代理模式实现图片的延迟加载const myImg={ setSrc(imgNode,src){ imgNode.src=src; }}const proxyImg={ setSrc(imgNode,src){ myImg.setSrc(imgNode,'./img.jpg'); //1. 加载占位图片 let img=new Img(); //2. 真正加载图片 img.src=src; img.onload=()=&gt;{ myImg.setSrc(imgNode,src); //3. 加载完成后，替换真正图片 } }}","link":"/2020/03/13/pattern/proxy-pattern/"},{"title":"桥接模式","text":"一、桥接模式及其应用桥接模式，将抽象部分跟具体实现部分分离，两者可以独立变化，也可以一起工作。中间通过‘桥’连接。如经常用到的组件上的那些方法，它们接受一个函数，如果用户传入这个函数，那么就会在某段代码逻辑里面使用。这个过程中，组件就是桥的作用，而用户传入的函数则是具体实现的部分了。 二、代码实现//例如array对象上的forEach方法，就是桥接模式的应用,forEach就是抽象部分，而具体实现是用户传入的回调函数。const forEach=(arr,callback)=&gt;{ if(!Array.isArray(arr)) return; const length=arr.length; for(let i=0;i&lt;length,i++){ callback(arr[i],i); }}let arr=[\"a\",\"b\"];forEach(arr,(el,index)=&gt;{ console.log(el+index);})","link":"/2020/03/13/pattern/bridging-pattern/"},{"title":"适配器模式","text":"一、适配器模式及其用途“水管弯弯”适配器模式，顾名思义，它就是对数据进行适配，将一个类的接口（方法亦或是属性）转换/过滤/重组成为另外的接口来满足需求。但常用在两个接口构造类似的情况下，如若两个大相径庭，适配模式就有点力不从心了。 二、代码实现适配框架大名鼎鼎的Jquery 框架大家都很熟悉吧，假设现在有一内部框架A，其结构与Jquery很类似，但是提供的方法却比较少，想引入Jquery却不想影响到之前写的代码，可以这样做 A.g =function (id){ return document.getElementById(id);}window.A = jQuery;//适配器方法A.g = function (id){ return $('#'+id)[0]} 数据适配假设有这样的各大音乐平台提供的数据，为了后台好处理，我们需要对数据进行适配 const API={ QQ:()=&gt;({ n:\"最了不起的你\", a:\"火箭少女101段奥娟\", f:0 }), Netease:()=&gt;({ name:\"最了不起的你\", author:\"火箭少女101段奥娟\", free:false })}const adapter=(info)=&gt;{ return { name:info.name||info.n, author:info.author||info.a, free:info.free||info.f }}","link":"/2020/03/13/pattern/adapter-pattern/"},{"title":"工厂模式","text":"一、工厂模式及其用途所谓工厂模式，就是根据不同的需求而”产出”相应的对象的类的实例，只对外提供一个根据不同参数来实例化相应的对象的函数。好处是在于可以避免了使用者于对象类之间的耦合，使用者完全可以不用知道这个类的细节，只需要懂得调用相应的方法。坏处也很明显，每个工厂只能”生产”同一类型的类的实例对象，当多类别对象的时候就不好用了，且当增加产品的时候需要更改判断的逻辑，繁琐 二、代码实现class Dog { run(){ console.log('狗'); }}class Cat { run(){ console.log('猫'); }}class Animal{ constructor(name){ name=name.toLocaleLowerCase(); switch(name){ case:'dog' return new Dog(); case:'cat' return new Cat(); default: throw TypeError(\"class name wrong\"); } }}const cat=new Animal(\"cat\");cat.run(); //狗","link":"/2020/03/13/pattern/factory-pattern/"},{"title":"命令模式","text":"一、命令模式 行为模式中的命令模式，是将可能请求的命令封装在一个对象中，交给中间人执行者，执行者再根据请求者的请求执行相应的命令。所以命令模式里面有三个主体。命令对象、执行者、请求者。应用场景就是当需要向命令对象发送请求的时候，不知道请求的对象具体是谁（执行者知道），更不知道被请求执行的操作是什么（命令对象知道），这个时候就用到命令模式了。优点就是高度松耦合，缺点嘛，就是需要定义三个对象且执行者跟命令对象之间的关系需要知道。 二、代码实现//定义一个命令对象，用来存储执行的操作const MenuBar = { refresh(){ console.log(\"执行了刷新操作\") }}//定义执行者函数，返回一个对象。用来执行命令const command = receiver=&gt;{ return { execute(){ receiver.refresh(); } }}//定义一个请求者,接受一个dom对象以及一个执行者const request = (button,command)=&gt;{ button.onclick=()=&gt;{ command.execute() } }}let refeshCommand = command(MenuBar);let button = document.xxxx;request(button,refeshCommand);","link":"/2020/03/13/pattern/command-pattern/"},{"title":"观察者模式","text":"一、观察者模式及其用途 观察者模式，行为型模式的一种，当存在一对多的关系的时候，用观察者模式可以实现当这个被观察的对象被修改的时候，会自动的通知订阅它的其他依赖对象。例如angular 的一个依赖库RXJS就是广泛的应用了这种模式。但常常会与发布-订阅模式傻傻分不清楚。 二、代码实现 观察者模式：只有观察者跟被观察者，两者是直接通信的(松耦合) function Subject() { //被观察者 this.observers = []; this.state = '快乐';}Subject.prototype.attach = function (observer) { this.observers.push(observer);}Subject.prototype.setState = function (state) { this.state = state; this.notify();}Subject.prototype.notify = function () { //被观察者状态改变的话是直接与观察者通讯 this.observers.forEach(function (observer) { observer.update(); })}function Observer(name,target){ // 观察者 一般会有一个方法 this.name = name; this.target = target;}Observer.prototype.update = function () { // 更新方法 console.log(`通知：${this.name} 当前的状态是 ${this.target.state}赶紧哄`) }let subject = new Subject();let observer1 = new Observer('儿子', subject);let observer2 = new Observer('女儿', subject);subject.attach(observer1); // 给目标添加观察者subject.attach(observer2);subject.setState('开心') 发布-订阅模式:发布者跟订阅者两个互不知晓，而是通过一个中间人来传递信息(如读者与作者，中间人是报社，完全没耦合) /*这里的event 相当于报社中间人,而fn读者,通过报社订阅报纸,当作者有新的东西的时候,就会通过报社出版新的*/ function Event(){ this.events=[]; } Event.prototype.on=function(fn){ //订阅 this.events.push(fn); } Event.prototype.emit=function(data){ //发布 this.events.forEach(function(fn){ fn(data); }) } 所以两者的区别就是发送方与接收方是否是知晓对方存在的，观察者模式中,被观察者状态一旦发生改变，订阅它的所有观察者都会立即知晓。而订阅发布模式中,发布者与订阅者是不知道对方是谁的，而是通过中间人（例如event）来联系。","link":"/2020/03/13/pattern/observer-pattern/"},{"title":"单例模式","text":"一、单例模式及其用途所谓单例模式，就是一个类就只有一个实例，用途的话可以用来定义命名空间，通过在一个实例对象定义其的方法跟属性，来达到命名不重复的目的，例如Jquery的$符号就是这个思想。再者就是如果对于一个类是负责连接数据库的线程池，日志等逻辑的，用到这种模式来保证对象不被重复创建，降低开销。 二、代码实现//惰性单例模式var laztSingle=(function(){ //使用闭包使得单例对象为私有 var instance=null; function Signle(){ return { age:1 } } return function(){ if(!instance){ instance=new Signle() } return instance }})()var a=lazySingle();var b=lazySingle();console.log(a===b) //true","link":"/2020/03/13/pattern/single-pattern/"},{"title":"策略模式","text":"一、策略模式及其用途 行为型模式之策略模式，实质就是将一系列可以互换的算法封装起来，每组算法处理的业务是一样的，但是处理的过程跟结果是不一样的。根据用户需求选择其中一种。优点是能将算法的使用跟实现进行分离，并且可以添加相应的算法。缺点就是得知道每种策略算法是异同点才能选择。 二、代码实现//策略类，定义相关的策略算法const strategies={ A(){ console.log(\"A\"); } B(){ console.log(\"B\"); }}//环境类，就是选择算法工具const context=name=&gt;{ return strategies[name]} context('A')() //A","link":"/2020/03/13/pattern/strategy-pattern/"},{"title":"寻找数是数字的数字之和的下标数组","text":"题目描述: 给出一个数与一个不重复的数组，如果这个数是数组里面两个数字之和，则返回下标数组。 思路: 传统做法是循环两次，比较两次下标值不同，但值相加相同的就返回，但时间复杂度就是O(n^2)。另外的一种做法就是利用map哈希列表来记录值与下标的映射，然后比较目标值与每次循环的当前值的差是否是在map中，是则表示存在，返回下标组。 代码实现 function twoSum (array,target){ const map = {}; for (let i = 0; i &lt; array.length; i++) { let n = array[i]; if( target-n in map){ //in针对的是数组的key，此时map的key是数组的值。 return [map[target-n],i]; }else{ map[n] = i; } }}console.log(twoSum([2,1,7,14],9)); //[0,2]","link":"/2020/05/06/programming/array-two-sum/"},{"title":"二叉搜索树的后序遍历序列","text":"题目描述: 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路: 二叉搜索树，左边的所有子节点永远比根节点小，右边的所有子节点永远比根节点大，虽然只有后序遍历的结果，但是可以结合二叉搜索树的特性，可以找出其根节点与分割左右子节点，因为左边是确定比根节点小的，所以只要比较分割出来的右子节点是否是所有都比根节点大，如果是，则继续递归比较，否则则可以直接确定不是二叉搜索树了。 代码实现 function VerifySquenceOfBST(sequence){ // write code here if(!(sequence.length)){return false} let root = sequence.pop();//根节点 后序根节点都是在数组的最后 let index = 0 let leftNodes = []; let rightNodes = []; while(root&gt;sequence[index]){ //寻找左右子节点的分割点。 index++; } leftNodes = sequence.slice(0,index); rightNodes = sequence.slice(index,sequence.length); if(leftNodes.length){ //因为上面的比较后，左边子节点就肯定是比根节点小的，所以直接递归处理就可以了 VerifySquenceOfBST(leftNodes) } if(rightNodes.length){ let flag = true; //右边节点的话，因为上面比较的时候，只是遇到比根节点大的值就停止移动index下标,没法保证后面的所有节点都遵从二叉搜索树的规则，需要一一比较。 rightNodes.forEach(item =&gt; { if(item&lt;root){ flag = false } }); if(flag){ VerifySquenceOfBST(rightNodes) }else{ return false; } } return true;}","link":"/2020/05/25/programming/binarySearchTree-sequentialTraversalSequence/"},{"title":"广度遍历实现深拷贝","text":"题目描述: 利用广度遍历的思想实现对象的深拷贝，且能处理好环状数据的问题。 思路: 根据广度遍历的思路，先遍历拷贝每一层级的对象，利用队列的先进先出的性质，记录同一层级的对象的子层级对象，再依次遍历拷贝各自子层级的对象。下面实现了基本的类型的拷贝，至于其他类型的得依照稍加处理。 代码实现 let _toString = Object.prototype.toString;let map = { array: 'Array', object: 'Object', function: 'Function', string: 'String', null: 'Null', undefined: 'Undefined', boolean: 'Boolean', number: 'Number'}//返回数据的类型function getType (obj){ return _toString.call(obj).slice(8,-1);}function isTypeOf(obj,type){ return map[type] &amp;&amp; map[type] ===getType(obj)}/** * @description: 广度遍历实现深拷贝,队列的方式来实现 * @param {object} obj 被拷贝的对象 * @param {Array} visitedArr 存储已拷贝的对象属性的数组,来处理环状数据问题 * @return: 深拷贝的对象 */function BFSdeepClone (obj,visitedArr = []){ let cloneObj = {}; //拷贝的对象 let sequeue = [obj]; //被拷贝的对象的队列 let cloneSequeue = [cloneObj]; //拷贝的对象的队列 while(sequeue.length){ let _obj = sequeue.shift(); //模拟队列.先进先出 let _cloneObj = cloneSequeue.shift(); //模拟队列,先进先出 if(isTypeOf(_obj,'array')||isTypeOf(_obj,'object')){ for (let item in _obj) { if(isTypeOf(item,'object')){ let index = visitedArr.indexOf(_obj[item]); //已经存在的对象属性直接赋值 if(index&gt;-1){ _cloneObj[item] = visitedArr[index]; } else{ sequeue.push(_obj[item]); _cloneObj[item] = {}; cloneSequeue.push(_cloneObj[item]); visitedArr.push(_obj[item]); } } else if(isTypeOf(item,'array')){ sequeue.push(_obj[item]); _cloneObj[item] = []; cloneSequeue.push(_cloneObj[item]); } else{ _cloneObj[item] = _obj[item]; //如果是普通值的话就直接赋值 } } } else{ _cloneObj = _obj; //如果是一开始就是普通值的话就直接赋值 } } return cloneObj;}//环状数据let Circle = { a: 1, b: { c: 1, d: 2, circle: null, }}Circle.b.circle = Circle.b;cloneCircle = BFSdeepClone(Circle);//如果不处理环问题会进入死循环console.log(cloneCircle);","link":"/2020/03/14/programming/BFS-deepClone/"},{"title":"深度遍历实现深拷贝","text":"题目描述: 利用深度遍历的思想实现对象的深拷贝，且能处理好环状数据的问题。 思路: 根据深度遍历的思路，针对每个对象属性深入递归拷贝下去，然后再遍历整个对象，在对每个对象属性都依照前面规则。下面实现了基本的类型的拷贝，至于其他类型的得依照稍加处理。 代码实现 let _toString = Object.prototype.toString;let map = { array: 'Array', object: 'Object', function: 'Function', string: 'String', null: 'Null', undefined: 'Undefined', boolean: 'Boolean', number: 'Number' } //返回数据的类型 function getType (obj){ return _toString.call(obj).slice(8,-1); } function isTypeOf(obj,type){ return map[type] &amp;&amp; map[type] ===getType(obj) } /** * @description: 深度遍历实现深拷贝，递归形式实现 * @param {object} obj 被拷贝的对象 * @param {Array} visitedArr 存储已拷贝的对象属性，来处理环状数据问题 * @return: 深拷贝的对象 */ function DFSdeepClone (obj,visitedArr = []) { let _obj = {} //拷贝的对象 // 如果拷贝的属性是一个对象的话 if(isTypeOf(obj,'array')||isTypeOf(obj,'object')){ let index = visitedArr.indexOf(obj); if(index &gt; -1){ _obj = visitedArr[index]; //如果是已经拷贝了的属性直接返回这个属性的值,处理回环问题 } else{ visitedArr.push(obj) //保存这个属性 //递归的深入每个属性嵌套的对象去拷贝 for (let item in obj) { _obj[item] = DFSdeepClone(obj[item],visitedArr) } } } else{ _obj = obj //如果是普通值的话就直接赋值 } return _obj } //环状数据 let Circle = { a: 1, b: { c: 1, d: 2, circle: null, } } Circle.b.circle = Circle.b; cloneCircle = DFSdeepClone(Circle);//如果不处理环问题会进入死循环 console.log(cloneCircle);","link":"/2020/03/14/programming/DFS-deepClone/"},{"title":"二叉树中和为某值的路径","text":"题目描述: 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 思路:叶节点，即是没有左右子节点的节点，利用递归的形式，从根节点往下寻找匹配的路径，每次保存路径后，判断当前的累加值是否与目标值相等且是否为根节点，如果是则将其路径的数组加入到路径数组中，否则则继续递归走左右子节点，最后需要注意，因为路径不止一条，不管找到与否，都得返回回去。 代码实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null;} */function FindPath(root, expectNumber){ // write code here if(!root){ return [] } let paths = []; //路径集合, preOrderTraverse(root,0,expectNumber,[],paths); return paths;}//前序遍历/** * @description:前序遍历寻找路径 * @param {array} root 树节点 * @param {number} currentNumber 当前值 * @param {number} expectNumber 目标值 * @param {array} path 当前路径集合数组 * @param {array} paths 最终路径数组 * @return: 深拷贝的对象 */function preOrderTraverse(root,currentNumber,expectNumber,path,paths){ currentNumber += root.val; path.push(root.val); //如果满足是叶节点且当前值刚好是等于期望值，则将路径添加到路径数组里面 if(root.left==null&amp;&amp;root.right==null&amp;&amp;currentNumber===expectNumber){ paths.push(path.slice(0)); //这里slice重新拷贝一份，防止跟随引用类型path的pop改变 } if(root.left){ preOrderTraverse(root.left,currentNumber,expectNumber,path,paths) } if(root.right){ preOrderTraverse(root.right,currentNumber,expectNumber,path,paths) } path.pop(); /* 这里弹出的原因是因为递归调用的时候传入的是同一个数组引用类型，路径又不止一个， 所以一边不管找到找不到都得回去，另外的路径才能是正确的。 */}","link":"/2020/05/25/programming/binaryTree-path-value/"},{"title":"跳台阶","text":"题目描述: 问题一：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。问题二：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路: 问题一：因为青蛙一次可以跳两种步伐，所以对于一级台阶、二级台阶，青蛙跳上去的情况是固定的一种与两种，现假设n为6，则跳上第6级台阶可以是从第5级台阶跳一级上来这一种，换句话说，有几种跳上5级台阶的方案就有几种跳上6级台阶的方案。跳上第6级台阶也可以是从第4级台阶跳两级上来，同样的有几种跳上4级台阶的方案就有几种跳上6级台阶的方案。即可以看出这个是一个跟斐波那契数列有点像的递归相加的情况，n级台阶的情况都可以看成是n-1级台阶的情况+n-2级台阶的情况，直到n=1或者n=2的时候。 问题二：其实这种情况第一次我是列出前面的一些结果发现这不是满足了数学的等比数列的通项公式吗，直接就写出来了。但换成另外的思路可以这样看，因为青蛙可以任意跳级，所以每个台阶都可以选择跳或者不跳2种选择，除了最终的台阶要存在，最后一阶是1，其他n-1都有两种情况。所以总的情况就算2^(n-1)*1 代码实现 //跳台阶function jumpFloor(number){ // write code here if(number==1){ return 1 }else if(number==2){ return 2 } return jumpFloor(number-1)+jumpFloor(number-2);}//变态跳台阶function jumpFloorII(number){ // write code here return Math.pow(2,number-1);}","link":"/2020/05/07/programming/dance-steps/"},{"title":"两个数组的交集","text":"题目描述: 给出两个任意可重复的数组，计算并返回两个数组的交集，例如[2,1,2,1]、[1,1]应该返回[1,1]。 思路: 一种做法是可以利用map对象来统计数组元素出现的个数，不过这次需要两个map来分别统计，最后再取两个数组相同值的最小次数，就是最后的结果。 代码实现 function intersection(arr1,arr2){ let map1 = {}; let map2 = {}; //两个map用来统计数组元素的出现个数 let result = []; for (let a1 of arr1) { if(map1[a1]){ map1[a1]++ }else{ map1[a1] = 1; } } for (let a2 of arr2) { if(map2[a2]){ map2[a2]++ }else{ map2[a2] = 1; } } for (let a2 of arr2) { while(map1[a2]&amp;&amp;map2[a2]){ //取两个数组的相同值的最小的个数 result.push(a2); map1[a2]--; map2[a2]--; } } return result}let a1 = [2,5,3,4];let a2 = [2,2,5,6];let a3 = [2,1,2,1];let a4 = [1,1];console.log(intersection(a1,a2)); //[2,5]console.log(intersection(a3,a4)); //[1,1]","link":"/2020/05/06/programming/intersection/"},{"title":"统计连续出现的字符及次数","text":"题目描述: 寻找一个字符串中连续出现最多的字符，并且统计其次数 思路: 最方便快捷的方法就是利用正则表达式匹配出连续出现的字符的内容数组，然后遍历数组，找出并统计连续出现最多的字符及其长度。 代码实现 function continuousRepetition(str){ let retObj = {}; let arr = str.match(/(\\w+)\\1+/g) //全局匹配第一个括号的正则表达式重复一次或多次的内容; let maxlen = 0; arr.forEach(element =&gt; { if(element.length&gt;maxlen){ maxlen = element.length; } }); arr.forEach((element)=&gt;{ if(element.length==maxlen){ retObj[element[0]] = maxlen; } }) return retObj}console.log(continuousRepetition(\"aabcccdaceddd\")); // { c: 3, d: 3 } 这里额外的补充一下用到的正则表达式中用到的\\num的含义 \\num用于匹配前的()的子表达式，例如\\1表示重复匹配第一个括号的正则的内容，上面的\\1+则表示匹配第一个括号中正则的内容重复一次或多次。num后面的元字符用法跟其他地方并无差异，详细可以参考正则表达式-菜鸟教程。其中需要注意的是当多个子表达式的时候需要满足整个大表达式，然后\\num再重复那个子表达式，这样的才能正确匹配，举个例子： /(123)(456)\\1/.test(\"123123456\"); //false/(123)(456)\\1/.test(\"123456123\"); //true/(123)(456)\\2?/.test(\"123456\"); //true ?代表0次或一次/(123)(456)\\2?/.test(\"123456456\"); //true","link":"/2020/05/05/programming/continuous-repetition/"},{"title":"对象数组转树形结构","text":"题目描述: 将一个含有可以组成树的对象数组转换为树形结构的数组。例如：[{id:1},{id:2,pid:1},{id:1},{id:3,pid:2},{id:4,pid:1}]转换结果是[{“id”:1,”childs”:[{“id”:2,”pid”:1,”childs”:[{“id”:3,”pid”:2}]},{“id”:4,”pid”:1}]}] 思路: 这个在实际应用还是比较经常遇到的，特别树形结构的目录，通常在后端存储的时候就只是一个类树型对象数组，需要前端自己拼接。利用一个map对象来记录id与对象的映射，遍历原数组，如果没有pid的话则是父节点，push到要返回的数组里面去。如果存在pid的话，则可以在map里面找到对应父对象，再将当前的节点对象存储到父对象的child数组里面。 代码实现 function objToTree (objArr){ let map = {}; let res = []; objArr.forEach(obj =&gt; { if(obj.id in map){//去重 return; } map[obj.id] = obj; //形成映射表 }); for (const item of Object.values(map)) { if(!item.pid){ res.push(item); //不存在pid,则是父节点 }else{ //否则则是子节点，找到映射表里面的父节点 let parent = map[item.pid]; parent.childs = parent.childs||[]; parent.childs.push(item); } } return res;}console.log(JSON.stringify(objToTree([{id:1},{id:2,pid:1},{id:1},{id:3,pid:2},{id:4,pid:1}])));// [{\"id\":1,\"childs\":[{\"id\":2,\"pid\":1,\"childs\":[{\"id\":3,\"pid\":2}]},{\"id\":4,\"pid\":1}]}]","link":"/2020/05/05/programming/objectToTree/"},{"title":"长整数相加","text":"题目描述: 两个任意大的整数相加的时候，可能会出现溢出、损失精度的情况，为了实现长整数相加，需要进行一些处理。 思路: 将两个长整数转换为字符串，然后通过分割进行一位一位的相加，需要注意的是进位的处理。 代码实现 function add (num1,num2){ let a = String.prototype.split.call(num1,\"\"); let b = String.prototype.split.call(num2,\"\"); let res = []; let addOne = 0; //进位数 //以两个数最长的那位为标准 while(a.length||b.length){ let item1 = parseInt(a.pop())||0; let item2 = parseInt(b.pop())||0; let temp = item1+item2+addOne; if(temp&gt;9){ temp = temp%10; addOne = 1; }else{ addOne = 0; } res.unshift(temp) //每次都从头插入 } if(addOne){res.unshift(1)} //当最后相加要进位的时候 return res.join('');} console.log(add(300000000000000000000,111111111111)); //300000000111111111111console.log(300000000000000000000+111111111111) //300000000111111100000","link":"/2020/05/05/programming/long-add/"},{"title":"顺时针打印矩阵","text":"题目描述: 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10 思路: 按照题目所述，顺时针的遍历整个矩阵，然后遍历完一圈后，往内缩小圈，改变上下左右的起点，直到left = right；top = bottom；注意进行往左与往上遍历的时候需要矩阵不止一行跟不止一列的时候才进行。 代码实现 function printMatrix(matrix){ // write code here var row=matrix.length; var col=matrix[0].length; var res=[]; if(row==0||col==0){ return res; } var left=0, top=0, right=col-1, bottom=row-1; while(left&lt;=right&amp;&amp;top&lt;=bottom){ for(var i=left;i&lt;=right;i++) res.push(matrix[top][i]); for(var i=top+1;i&lt;=bottom;i++) res.push(matrix[i][right]); if(top!=bottom){//当不止一行的时候才有逆时针的水平方向 for(var i=right-1;i&gt;=left;i--) res.push(matrix[bottom][i]); } if(left!=right){//当不止一列的时候才有逆时针的垂直方向 for(var i=bottom-1;i&gt;top;i--) res.push(matrix[i][left]); } left++,top++,right--,bottom--; } return res;}","link":"/2020/05/24/programming/matrix-clockwise/"},{"title":"二进制中1的个数","text":"题目描述: 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路: 方法一：先将整数转换为32为二进制数字，正数的话直接使用正则表达式匹配1的数字的结果，求其长度，负数的话需要先取其补码，这时候就用到了之前写的长整数相加了。最后也是用正则表达式匹配1的结果。 方法二：不断左移与数字进行与运算计算出1的个数,在与运算的时候负数会先取补码。 代码实现 //方法一function add (num1,num2){ let a = num1.split(\"\"); let b = num2.split(\"\"); let res = []; let addOne = 0; //进位数 //以两个数最长的那位为标准 while(a.length){ let item1 = parseInt(a.pop())||0; let item2 = parseInt(b.pop())||0; let temp = item1+item2+addOne; if(temp&gt;1){ temp = temp%2; addOne = 1; }else{ addOne = 0; } res.unshift(temp) //每次都从头插入 } if(addOne){res.unshift(1)} //当最后相加要进位的时候 return res.join('');}function NumberOf1(n){ if(n&gt;0){ let numberStr = (n).toString(2); return numberStr.match(/1/g).length; }else if(n&lt;0){ //负数的情况 let numberStr = Math.abs(n).toString(2); if(numberStr.length&lt;32){ let addLength = 32-numberStr.length for(let i =0;i&lt;addLength ;i++){ numberStr = '0'+numberStr; } } numberStr = numberStr.replace(/0/g,8).replace(/1/g,0).replace(/8/g,1); numberStr = add(numberStr,\"1\"); return (numberStr.match(/1/g).length); }else{ return 0}//方法二function NumberOf1(n){ // write code here var count = 0,flag=1; while(flag){ if(n&amp;flag)count++; flag=flag&lt;&lt;1; } return count;}","link":"/2020/05/07/programming/oneNumber-binary/"},{"title":"有序数组的中位数","text":"题目描述: 给出两个有序数组，计算两个有序数组的中位数，且算法复杂度不超过O(log(m+n))。 思路: 因为两个是有序的数组，所以只需逐个比较大小组成新的数组即可，再根据奇偶性求出中位数。 代码实现 function findMiddle(arr1,arr2){ let arr = []; while(arr1.length&amp;&amp;arr2.length){ //如果都是升序的话，排列两个数组的元素，也是升序 if(arr1[0]&lt;arr2[0]){ arr.push(arr1.shift()) }else{ arr.push(arr2.shift()) } } arr = arr.concat(arr1,arr2); if(arr.length %2==0){ let mid = arr.length/2; return (arr[mid]+arr[mid-1])/2; }else{ return arr[Math.floor(arr.length/2)]; }}console.log(findMiddle([1,3,4],[2,5])); //3","link":"/2020/05/06/programming/order-median/"},{"title":"栈的压入、弹出序列","text":"题目描述: 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路: 因为一个压栈序列，出栈的顺序可能有许多种，例如上面的例子，1 2 3 4 5是压栈顺序，4 5 3 2 1 是一种，5 4 3 2 1 也是其中一种。但不变的是压栈进入的序列，出栈后，压栈的序列将是空的。所以可以利用一个辅助栈，作为压栈序列与出栈序列的中间栈，来模拟压栈与出栈的各种情况。如果最后的辅助栈的长度为空，则证明这个弹出序列是压入序列的一种。否则就不是。 代码实现 function IsPopOrder(pushV, popV){ // write code here let stack = []; //辅助栈 if(pushV.length==0||popV.length==0){ return false } for(let i =0;i&lt;pushV.length;i++){ stack.push(pushV[i]); //借助辅助栈，模拟每次压栈出栈的可能性。 while(stack.length&gt;0&amp;&amp;stack[stack.length-1]==popV[0]){ stack.pop(); popV.shift(); } } return stack.length&gt;0?false:true;}","link":"/2020/05/24/programming/pop-push-sequence/"},{"title":"从上往下打印二叉树","text":"题目描述:从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路: 题目的意思，其实就是一个树的广度遍历。所以第一种方式就是使用递归的形式去实现。第二种呢，则是可以通过队列的方式，每次存储其左右子树，然后利用队列先进先出的特性，则可以实现从上往下，从左往右的打印节点。 代码实现 /* function TreeNode(x) { this.val = x; this.left = null; this.right = null;} *///方法一 递归function PrintFromTopToBottom(root){ // write code here let treeNodeList = []; let i =0; if(!root){ return [] } function PrintFromTopToBottomSearch(node){ if(!node){return} if(node.left){ treeNodeList.push(node.left); } if(node.right){ treeNodeList.push(node.right); } node = treeNodeList[++i]; PrintFromTopToBottomSearch(node); } treeNodeList.push(root); PrintFromTopToBottomSearch(root); treeNodeList = treeNodeList.map(item=&gt;{return item.val}) return treeNodeList}//方法二 队列function PrintFromTopToBottom(root){ const queue = []; const res = []; queue.push(root); while(queue.length){ let temp = queue.shift(); if(temp.left !== null){ queue.push(temp.left); } if(temp.right !== null ){ queue.push(temp.right); } res.push(temp.val); } return res;}","link":"/2020/05/25/programming/print-binaryTree-topTobottom/"},{"title":"复杂链表的复制","text":"题目描述: 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。 思路: 本身链表的拷贝很简单，但是因为这个链表的节点里面有一个随机的属性random指向了随机节点。1)传统的思想，先不考虑随机指针属性，先顺序拷贝链表，同时使用一个map来记录当前节点与随机节点的关系。然后最后再遍历一遍将其随机节点的属性带上。2)方法二，遍历每个节点，拷贝一份副本节点跟在原节点后面，例如A-&gt;A1-&gt;B-&gt;B1。这样做的好处是无需额外的记录一个节点的随机指针的参照表，因为假如遍历的时候发现A的随机节点是C，那很容易就知道A1的随机节点是C1。最后再通过将奇偶节点断开，即分开原链表与拷贝的链表即可。 代码实现 function RandomListNode(x){ this.label = x; this.next = null; this.random = null;}//方法一function Clone(pHead){ if(!pHead){ return null } let map = {}; //随机指针参照表 let newHead = null; //拷贝的链表的头部 let cur = pHead; while(cur){ //遍历原链表，找出当前节点与其随机指针的对应关系 if(cur.random){ map[cur.label] = cur.random.label; } cur = cur.next; } let newHeadArray = []; //用数组的形式来表示新的链表 cur = pHead; while(cur){ let item = new RandomListNode(cur.label); newHeadArray.push(item); cur = cur.next; } for(let i =0;i&lt;newHeadArray.length;i++){ let mapValue = map[newHeadArray[i].label]; if(mapValue){ //如果参照表里面有相应的值的话，则找到其对应的随机指针指向的节点，赋值。 let randomNode = newHeadArray.find(item=&gt; item.label === mapValue); newHeadArray[i].random = randomNode; } newHeadArray[i].next = newHeadArray[i+1]?newHeadArray[i+1]:null; } newHead = newHeadArray[0]; return newHead;}//方法二function Clone(pHead){ // write code here if(!pHead){ return null } var cur,newpHead; //当前的节点与新的链表头节点 cur = pHead ; //克隆当前节点，链接在当前节点的身后 while(cur){ let tem = new RandomListNode(cur.label); tem.next = cur.next; cur.next = tem; cur = cur.next.next; cur = pHead; //克隆随机节点 while(cur){ if(cur.random){ cur.next.random = cur.random.next; } cur = cur.next.next; } newpHead = pHead.next; cur = pHead; //断开奇偶节点，其中偶数节点就是克隆后的对象 while(cur){ let tem = cur.next; cur.next = tem.next; tem.next = tem.next ? tem.next.next:null; //如果原本的节点有值的话，证明之前肯定复制了一个在其后面，如果没有的话，则需要区别之前的重新赋值null cur = cur.next; } return newpHead;}","link":"/2020/05/25/programming/replication-complexLists/"},{"title":"重建二叉树","text":"题目描述: 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路: 因为前序与中序在各自左右节点下的序列内容是一样的，利用前序与中序的性质，（在前序中根节点永远是在第一个的，利用前序得出的根节点在中序里面可以分割出左右节点的序列）进行递归处理。注意递归的出口！ 代码实现 function TreeNode(x) { this.val = x; this.left = null; this.right = null;} /* * @description: 重建二叉树 * @param {Array} pre 前序数组 * @param {Array} vin 中序数组 * @return: 二叉树*/function reConstructBinaryTree(pre, vin){ var rootTreeNode = null; //根节点 if(pre.length&gt;1){ //多个节点的时候 let vinIndex = vin.indexOf(pre[0]); //分割下标 let rootTreeNode = new TreeNode(pre.shift()); let vinLeftArray = vin.slice(0,vinIndex); let vinRightArray = vin.slice(vinIndex+1); let preLeftArray = pre.slice(0,vinIndex); let preRightArray = pre.slice(vinIndex); rootTreeNode.left = reConstructBinaryTree(preLeftArray,vinLeftArray); rootTreeNode.right = reConstructBinaryTree(preRightArray,vinRightArray); return rootTreeNode; }else if(pre.length==1){ rootTreeNode = new TreeNode(pre[0]); //只有一个节点的时候 return rootTreeNode; }else { return null }}console.log(reConstructBinaryTree([1,2,3,4,5,6,7],[3,2,4,1,6,5,7]))","link":"/2020/03/14/programming/rebuild-binaryTree/"},{"title":"从尾到头打印链表","text":"题目描述: 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 思路: 理解了链表的数据结构后其实很简单，只需要遍历链表，然后利用数组的unshift方法每次将链表的下一个值插入到数组的前面，从而实现逆序。 代码实现 function ListNode(x){ this.val = x; this.next = null;}function printListFromTailToHead(head){ let array = []; //返回的数组 let node = head; while(node!==null){ array.unshift(node.val); node = node.next; } return array;}","link":"/2020/05/06/programming/reverse-linked/"},{"title":"旋转数组的最小数字","text":"题目描述: 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路: 最笨的方法就是逐个比较后确定最小值，但没利用好是一个非递减排序好的数组的特性，所以利用二分法来查找是比较有效果的。因为无论是奇数数组或者是偶数数组，二分到最后的两个值的区间的时候，最小值永远都会在右边。 代码实现 function minNumberInRotateArray(rotateArray){ // write code here if(rotateArray.length==0){ return 0; } let left = 0; let right = rotateArray.length-1; let mid = null; while(left&lt;right){ if(left+1==right){ return rotateArray[right]; //旋转后最小值永远都会是在右边 } mid = Math.floor((left+right)/2); //因为非递减所以是递增或者相等的数组的旋转,所以当中间值大于左边界值的时候，最小值在右边 if(rotateArray[left]&lt;=rotateArray[mid]){ left = mid; }else if(rotateArray[right]&gt;=rotateArray[mid]){ right = mid; } } return rotateArray[right]; //旋转后最小值永远都会是在右边 }","link":"/2020/05/07/programming/smallNumber-rotateArray/"},{"title":"树的子结构","text":"题目描述: 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路: 如果B是A的子结构的话，则A树的任意一直遍历结果一点包含了B树的那一种遍历结果，所以可以先将两棵树使用前序遍历的方式获取遍历后的结果数组。 代码实现 function TreeNode(x) { this.val = x; this.left = null; this.right = null;}//前序遍历 function preorders(pRoot){ let array = []; function preorder(pRoot){ if(pRoot){ array.push(pRoot.val); preorder(pRoot.left); preorder(pRoot.right); } } preorder(pRoot); return array;}function HasSubtree(pRoot1, pRoot2){ // write code here if(!pRoot2){ return false; } let array1 = preorders(pRoot1); let array2 = preorders(pRoot2); if(array1.join(\"\").includes(array2.join(\"\"))){ return true; }}","link":"/2020/05/07/programming/tree-substructure/"},{"title":"CSS3 常见知识(一)","text":"👇内容速览👇 常见的几种居中方法 浮动与BFC 与浏览器性能相关 常见的几种居中方法 使用position定位及transform特性 &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt;&lt;/div&gt;.container{ position:relative;}.content{ position:absolute; top:50%; /*这两个百分比是相对父元素的*/ left:50%; transform:translate(-50%,-50%) /*这里的百分比是相对与本身的*/}/*或者*/.container{ position:relative;}.content{ position:absolute; left:0; top:0; right:0; bottom:0; /*让其自动分布*/ margin:auto} flex布局 .container{ display:flex; justify-content:center; align-items:center;} 使用伪元素 .container{ width:200px; height:200px; /*水平居中*/ text-align:center;} /*定义一个基线，垂直居中是需要一个行内元素的基线来作为标准的 :after出现的意义就是在于利用display:inline-block和height:100% 这俩属性完成行内与基线这俩个大前提要求 (即行内块元素，高度100%自然就以高度50%处即平常所说的中线为基线*/.container:before{ content:\"\"; display:inline-block; height:100%; vertical-align:middle;}.content{ display:inline-block; /*根据之前定义的基线进行对齐*/ vertical-align:middle;} 浮动与BFC 浮动：浮动基本就不说了，一些细节就是普通的元素与浮动元素一起后，会被浮动元素所遮挡，但是里面的文字却可以看到这个浮动元素，围绕在这个浮动元素的周围。浮动是对于所在的那一行的，声明为浮动的元素不管是内联还是块级元素，都会生成一个块级框，如果两个浮动元素因为放不下而导致了一个向下移动，可对下移的元素设置负外边距使其上移。 清除浮动的方法 伪元素清除浮动 .clearfloat:after{ content:''; display:block; height:0; visibility:hidden; clear:both;} 声明BFC清除浮动 .clearfloat{ overflow:auto;} BFC:块级格式上下文，规定了内部块级盒子的布局。float不为none，position为absolute、fixed，display为flex、inline-block的，overflow不为visible的都能产生BFC。特性跟作用如下： 特性：①属于一个BFC的两个相邻盒子之间的margin会出现重叠的情况。②BFC区域不会与浮动的区域发生交集，而是紧贴在浮动边缘。③BFC计算高度的时候把浮动元素也计算在里面，所以可以用来清除浮动 作用：①清除浮动，因为特性三。②解决外边距合并问题，属于同一个BFC的两个相邻的盒子外边距会重叠，将其中一个盒子display声明为inline-block。③制作自适应两栏布局，布局之间没有缝隙。 与浏览器性能相关 回流与重绘： 回流：当dom tree 与css rule tree 结合生成render tree后，需要计算在设备视图中的位置跟大小，这个过程就是回流。 重绘：在回流阶段后，得到了节点的大小，位置等几何信息，将其转换为屏幕的实际像素的过程，就是重绘。 引发回流重绘的原因： 页面一开始的渲染 dom节点位置、大小发生变化 添加/删除dom节点 浏览器尺寸发生变化 减少回流跟重绘：因为每次回流跟重绘都比较耗浏览器的性能，所以要尽量减少其次数，常见的方法就是批量修改dom，或者先将dom元素脱离文档流，修改完成后再带回文档。多修改class少使用style。 css文件的导入跟位置： 导入文件的时候link标签导入跟import 的区别 href：超文本链接，用来建立文档与元素的之间的链接，浏览器会识别当前是css文件，并行下载文档，不会阻塞一开始的加载过程。（多用） source：引入src所指向的内容，浏览器遇到该元素的时候，会停止对页面的渲染，转而去加载相应的资源，直到加载完成。（少用） 位置：css文件尽量放在head里面，因为css的加载过程中因为跟dom树生成是并行的，所以不会影响到dom树，但是会影响到最后的render树的生成，从而会影响到回流重绘。所以link标签最好是尽量放在head里面，因为dom树的解析是自上而下，这样可以加快render树的生成。","link":"/2020/03/13/ui/css-base1/"},{"title":"webpack4配置文件及其相关概念","text":"配置文件 webpack默认识别的配置文件是webpack.config.js。但是在日常的项目中，通常有分生产环境与开发环境，所以可以通过webpack –config 指定配置文件。例如webpack –config webpack.pro.js。在package.json里面脚本配置。打包的命令是./node_modules/.bin/webpack。原理是局部安装的依赖如果有创建一些命令的话，会在node_modules/.bin目录创建软链接。而package.json默认会读取这些软链接。所以可以在package.json的脚本里面配置命令。 打包输出结果 module.exports = { entry:{ index:'./src/index.js', utils:'./src/util.js' }, output:{ path:path.join(__dirname,'dist'), filename:'[id].bundle.js' }, mode:'production'} Hash: 8a5dd3006c8eb99d09ca //本次打包对应的唯一的一个hash值Version: webpack 4.41.6 //webpack 版本Time: 96ms //打包耗时Built at: 2020-02-16 8:16:35 PM /* 打包出的文件 文件大小 chunks id数组 asset对应的chunk名称 就是entry指定对象的key 当entry是字符串的时候，会默认指定名称为main*/ Asset Size Chunks Chunk Names0.bundle.js 976 bytes 0 [emitted] index1.bundle.js 1020 bytes 1 [emitted] utilsEntrypoint index = 0.bundle.js //打包入口文件及输出的结果Entrypoint utils = 1.bundle.js[0] ./src/util.js 179 bytes {1} [built][1] ./src/index.js + 1 modules 378 bytes {0} [built] //chunk 0 里有引用关系的文件列表| ./src/index.js 196 bytes [built]| ./src/hello.js 182 bytes [built] module、chunk、bundle在webpack里面的意义与区别 module：我们写的每个文件，如js文件,css文件，jsx文件。甚至是被引用的一张图片。都是认为是module。 chunk：webpack在运行打包的时候，根据文件的引用关系生成chunk文件，然后在对这个chunk文件进行相关操作。例如上面例子，index.js引用了hello.js文件，这两个就生成了chunk文件。 bundle：webpack处理完chunk文件后，最终输出的就是bundle文件。这个文件包含了加载与编译后的最终源文件，可以直接在浏览器运行。 一般来说，一个chunk会对应一个bundle，但是也有例外，例如我在index.js里面引入了index.css文件,但我用插件将其分割出来生成了index.bundle.css文件。这个时候这个chunk就对应了两个bundle。 总结来说，我们编写的是module，webpack运行的时候是chunk，最终输出的是可以直接运行的bundle。","link":"/2020/03/15/webpack4/webpack4-base1/"},{"title":"CSS3 常见知识(二)","text":"👇内容速览👇 各种像素的区别与理解 那些年遇到过的”视口” 移动端适配的一些小理解 各种像素的区别与理解 设备像素：设备像素，即物理像素、在设备出厂的时候就已经固化好了。 设备独立像素：逻辑像素，在缩放比例等于100%的时候，一个设备独立像素刚好就等于一个css像素。举个例子，在谷歌浏览器控制台切换到移动设备的时候所显示的。为什么又了物理像素还要引入这些像素来混淆呢。因为呀，在很多情况下，很多手机的屏幕尺寸不变，但是他的分辨率却提高了好几倍，导致了在相同尺寸不同分辨率的手机上，如果都按物理像素那样子计算的话，在低分辨率的手机上，能够撑满的内容，在高分辨率的手机上，往往会缩小好几倍。达不到我们想要的兼容效果。所以要引入一个新的单位来统一的计算。也就有了所谓的设备像素比（dpr）。 设备像素比：dpr =设备像素/设备独立像素，例如，iPhone6的设备像素比是2，即一个设备独立像素等于两个物理像素。 //在js获取window.devicePixelRatio//css 获取 当设备的dpr大于等于3的时候，字体显示红色@media (min-resolution: 3dppx) { body { color: red; }} 那些年遇到过的”视口” 布局视口：在pc浏览器上，布局视口等于浏览器的窗口大小，但不包括（border,margin,滚动条宽度）包括内容跟padding。在移动端，这个被默认的设置为980px,本意是为了让pc浏览器的页面能完整的显示在移动端，但是相应的页面就要进行缩小处理，进而此时css像素就不会等于设备独立像素。 视觉视口：用户在屏幕看到的真实区域，在pc浏览器上，视觉视口就是等于浏览器的窗口大小，但不包括（border,margin）但包括滚动条宽度。在移动端，这个被默认的设置为981px。用户缩放浏览器，不会改变布局视口，但是会改变视觉视口。 理想视口：谷歌浏览器调试移动端的到时候页面给的像素大小，像素单位是设备独立像素。 让css像素等于设备像素 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;/*width=device-width作用是将viewport宽度设置为设备独立像素的宽度-&gt;即布局视口等于理想视口。这时候css像素就与设备独立像素一一对应，此时的innerWidth就是设备独立像素的大小而不是980px了initial-scale 默认缩放比例，100%，如果改变的话比如width: 128px。css像素的大小是很容易变化的。当我们缩放页面的时候，元素的css像素数量不会改变，改变的只是每个css像素的大小。也就是说width: 128px的元素在缩放200%以后，宽度依然是128个css像素，只不过每个css像素的宽度和高度变为原来的两倍。如果原本元素宽度为128个设备独立像素，那么缩放200%以后元素宽度为256个设备独立像素（css像素宽度始终是128）放大的时候，视觉视口的大小即用户看到的大小就会变小，所以理想视口/视觉视口=设备独立像素/css像素=页面的缩放比例ps：可以设置禁止缩放来达到css像素与设备独立像素的1:1，但用户体验可能会不好*/ 浏览器的一些相关大小获取：当页面缩放比例为 100%时， CSS像素=设备独立像素，理想视口=视觉视口。 window.innerHeight：获取浏览器视觉视口高度（包括垂直滚动条）。 window.outerHeight：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。 window.screen.Height：获取获屏幕取理想视口高度，这个数值是固定的。 window.screen.availHeight：浏览器窗口可用的高度。 document.documentElement.clientHeight：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。 document.documentElement.offsetHeight：包括内边距、滚动条、边框和外边距。 document.documentElement.scrollHeight：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与 clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。 移动端适配的一些小理解 flexible方案：使用rem来布局，缺点计算比较繁琐，但是有插件可以支持 (function (win, doc) { if (!win.addEventListener) return; var html = document.documentElement; function setFont() { var cliWidth = html.clientWidth; var rem = clientWidth /10 html.style.fontSize = rem+'px' //将font-size设置为布局视口的1/10 } win.addEventListener('resize', setFont, false) doc.addEventListener('DOMContentLoaded', setFont, false)})(window, document); vw,vh 视口宽度视口高度百分比，将视口宽度跟视口高度分为100份，每份是1%。缺点是px转换为vw的时候不一定能整除。 解决1px适配问题：在设备像素比大于1的设备上，1px是被多个物理像素渲染。 /*使用伪类跟媒体查询*/.border_1px:before{ content:'', position:absolute; height:1px; width:100%; backgorund-color:#000; transform-origin:50% 0;}/*2倍屏*/@media only and screen(min-resolution: 2dppx) { .border_1px:before{ transform:scaleY(0.5) }}/*3倍屏*/@media only and screen(min-resolution: 3dppx) { .border_1px:before{ transform:scaleY(0.33) }}","link":"/2020/03/13/ui/css-base2/"},{"title":"webpack基本配置(上)","text":"entry(入口) webpack打包的入口,根据这个入口文件及里面文件的相关依赖来开始构建,可以指定单个或者多个入口。举个例子 module.exports = { entry:'./src/index.js', //单个入口的时候是字符串 默认是.src/index //多个入口的时候是对象。可以动态配置 entry:{ phone:'./src/phone.js', pc:'./src/pc.js' } } output(出口) webpack打包生成的bundle的最终出口，可以指定文件所在的目录及命名格式等配置，按需加载的文件名称等。具体更多的配置可参照官网的。举个例子 module.exports = { output:{ path:path.join(__dirname,'dist'), filename:'bundle.js' //单入口的时候 filename:'[name].bundle.js' //多入口的时候使用入口名称占位符 filename:'[id].bundle.js'//多入口使用内部chunk id占位符 filename: \"[name].[hash].bundle.js\" //多入口的时候使用入口名称占位符加每次打包的hash chunkFilename: 'chunk.bundle.js', // 指未列在 entry 中，却又需要被打包出来的文件的名称,通常指按需加载的代码 },} loaders webpack默认只支持js/json两者文件类型，需要通过loaders来支持其他文件类型并转换为有效的模块，从而可以添加到依赖图。本身是一个函数，接受源文件作为参数，返回转换的结果，可以对一个规则指定多个loader,指定多个loader的时候，执行是从右到左。举个例子 module.exports = { module: { rules: [ { test: /\\.css$/, //匹配规则，以.css为结尾的文件 use:['style-loader','css-loader'] //或者 loader:'style-loaer!css-loade' /*loader需要相应配置的时候*/ use: [ { loader: 'style-loader' }, //将生成的css代码放在一个style标签里面，放到head标签，当样式代码太大的时候不好用，需要使用plugin抽离出成为css文件link引用 { loader: 'css-loader', //支持.css文件的加载与解析 如import style.css options: { modules: true } } ], exclude: /node_modules/ } ] }} plugins 用于最终bundle文件的优化，资源管理和环境变量注入，弥补loaders没有的功能。后面很多内容配置都会用到相关的plugin，有些是webpack自带的有些是社区需要额外下载的，举个例子，webpack自带的定义全局变量插件 module.exports = { /*使用JSON.srtingfy的原因是definePlugin插件声明的全局变量是直接将内容替换了，如果不stringfy的话 \"development\"最后变成development变量了， \"'development'\" 才会等于'devlopment'*/ new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"development\") }), } mode 告知webpack使用相应模式的内置优化：有两个选项，一个是development，将process.env.NODE_ENV设置为development,同时启用webpack在开发环境的相关插件。另外一个production，将process.env.NODE_ENV设置为production，同时启用webpack在生产环境的相关插件(后面会讲到)。 module.exports = { + mode: 'development' //等同于使用下面这些插件 - plugins: [ - new webpack.NamedModulesPlugin(), - new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"development\") }), - ]}","link":"/2020/03/15/webpack4/webpack4-base2/"},{"title":"webpack基本配置(下)","text":"watch 文件监听配置，在源码发生变化的时候，自动重新构建出新的输出文件。因为是输出在磁盘里面的文件，所以每次更新后得手动刷新浏览器。可以在配置文件配置或者在脚本后面加上--watch参数开启。 //文件监听的原理：轮询判断文件的最后编辑时间是否变化，当某个文件发生变化后，并不是立刻的告诉监听者，而是先缓存起来，等待aggregateTimeout再去通知module.exports = { watch:true, watchOptions:{ ignored:/node_modules/, //不监听变化的文件或者文件夹，支持正则 aggregateTimeout:300, //监听到变化后等待300ms后再去执行。默认是300ms poll:1000 //判断文件是否发送变化是通过不停询问系统指定文件有没有变化实现的，默认每秒询问1000次 }} webpack-dev-server 在开发环境的时候，使用webpack-dev-server来开启一个本地服务器来实时监听文件的变化。开启热更新(不用刷新浏览器就能显示最新的结果) npm i webpack-dev-server -D module.exports={ plugins:[ new CleanWebpackPlugin(), //自动清除目录插件 new HtmlWebpackPlugin({template:'./src/index.html',filename:'index.html'}), new webpack.HotModuleReplacementPlugin() /*webpack 构建出来的 bundle.js 本身是不具备热更新的能力的， HotModuleReplacementPlugin 的作用就是将 HMR runtime 注入到 bundle.js， 使得bundle.js可以和HMR server建立websocket的通信连接。*/ ], devServer:{ contentBase:'./dist', /*默认的话webpack-dev-server会为根文件提供一个本地服务器， 如果想为另外的目录下文件提供本地服务器的话，在这里设置。 注意如果想获取到实时的数据变换的话文件夹里面必须有一个html文件且文件里面引入的脚本得以'/'来指定是获取内存里面的文件而不是磁盘上的旧的打包的文件。 如果有指定HtmlWebpackPlugin插件来使得html文件也是在内存中的话，就可以不用设置这个参数。*/ hot:true,//开启热更新 port:8080, //设置端口，默认是8080 historyApiFallback:true //在开发单页应用时，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html }} 热更新原理分析 文件通过编辑后经过文件系统，传输给webpack compiler将js编译成为bundle.js。再由Bundle server提供个端口服务让文件在浏览器访问。一开始的过程是12AB。而后的更新过程则是依靠另外的一个服务器HMR server 与浏览器进行websocket通信。HMR Server 是服务端，用来将变化的 js 模块通过 websocket 的消息通知给浏览器端。HMR Runtime是浏览器端，用于接受 HMR Server 传递的模块数据。webpack 构建出来的 bundle.js 本身是不具备热更新的能力的，HotModuleReplacementPlugin 的作用就是将 HMR runtime 注入到 bundle.js，使得bundle.js可以和HMR server建立websocket的通信连接。 WDM 另外的一种形式就是使用webpack-dev-middle中间件搭配express自己搭建一个服务器来实现热更新，可以更加灵活。 const express = require('express');const webpack = require('webpack');const webpackDevMiddleware = require('webpack-dev-middleware');const app = express();const config = require('./webpack.config.js');const compiler = webpack(config); //使用webpack内置的编译配置文件app.use(webpackDevMiddleware(compiler,{ publicPath:config.output.publicPath}));app.listen(3000); 文件指纹策略 上面也讲到，输出文件的时候可以指定hash值来命名文件。可以根据这个值来确定文件是否改变过，进而决定要不要使用缓存等操作。hash一般是结合CDN缓存来使用的，文件发生变化的话，对应的文件的hash就会发生改变，对应的 HTML 引用的 URL 地址也会改变，触发 CDN 服务器从源服务器上拉取对应数据，进而更新本地缓存。webpack中有三种hash来命名文件，分别是hash、chunkhash、contenthash。区别如下： hash：跟整个项目每次打包有关，只要项目文件有修改，即重新build的话，整个项目的hash就会发生改变。多页面项目打包的话就不用这个了，动一发而牵全身。 chunkhash：与打包过程的chunk有关，根据不同的entry入口进行文件依赖解析，构建对应的chunk，生成相应的hash值。多页面打包的时候就用这个，只修改相应模块，其他模块将不受影响。 contenthash：顾名思义，它更加细，只有相应的文件的内容发生改变才会改变，例如index.css文件与index.js文件在同一个chunk,但一般都是js发生改动比较多，所以这个时候就设置css的命名用contenthash。改变index.js的时候就不会影响到index.css文件。 文件压缩 js文件压缩：webpack4之后内置了uglifyjs-webpack-plugin对打包的js文件进行了压缩。 css文件压缩：使用optimize-css-assets-webpack-plugin及cssnano来对css文件进行压缩。plugins:[ new CleanWebpackPlugin(), //自动清除目录插件 new HtmlWebpackPlugin({template:'./src/index.html',filename:'index.html'}), new MiniCssExtractPlugin({ filename:'./static/css/[name]_[contenthash:8].css', //将css 抽离成单独的文件 chunkFilename:'[id].css' }), new OptimizeCssassetsWebpackPlugin({ //压缩css插件 assetNameRegExp:/\\.css$/g, cssProcessor:require('cssnano') //使用cssnano来压缩css代码 })], html文件压缩：HtmlWebpackPlugin里面就可以配置minfy来实现压缩。plugins:[ new HtmlWebpackPlugin({ template:path.join(__dirname,'src/index.html'), filename:'index.html', chunks:['index'], //针对多入口文件,就是选择要html嵌入的js文件 inject:true, //放置js文件的位置，如果设置为 true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部，'head' 将放置到 head 元素中。false则不会引入。 minify:{ html5:true, collapseWhitespace:true,//去除空格换行符 removeComments:true,//是否去除注释 minifyCSS:true, //压缩一开始就内联在 html 里面的css和js minifyJS:true, preserveLineBreaks:false } }),],","link":"/2020/03/15/webpack4/webpack4-base3/"},{"title":"webpack进阶使用(上)","text":"实现自动补充样式前缀与px转rem使用postcss(后处理器)来实现自动补充样式前缀与px转rem。在wepack中使用postcss-loader来实现postcss的功能。实现px转rem的话也可以使用px2rem-loader，这里为了方便一起使用就用了postcss的插件来实现。另外还需要动态指定html的px来实现自适应。可以使用阿里移动端的lib-flexible库(根html元素的fons-size的计算，获取的是当前浏览器的宽度/10)，也可以自己写。 { test:/\\.css$/, use:[ MiniCssExtractPlugin.loader, 'css-loader', { loader:'postcss-loader', options:{ plugins:()=&gt;[ require('autoprefixer')({ //自动补齐前缀 browsers:[\"last 2 version\",\"&gt;1%\"] //最新的两个版本且使用率大于1%的浏览器 }), require('postcss-plugin-px2rem')({ //1rem 等于多少px 默认是1rem 等于100px //这个值要根据你设计稿与根元素的自适应设置而定 rootValue:75, unitPrecision:8, //允许REM单位增长到的十进制数字，貌似没什么用 propWhiteList: [], //白名单，默认空数组不启用 匹配正则 propBlackList: [], //黑名单，默认空数组不启用 匹配正则 exclude:false, //排除的目录 支持正则 selectorBlackList: [], //要忽略并保留为px的选择器 ignoreIdentifier: false, // replace: true, mediaQuery: false, //允许在媒体查询中转换px minPixelValue: 1 //设置要替换的最小像素值(1px会被转rem) 默认 0 }) ] } } ],} 多页面打包动态的设置入口配置及动态创建html-webpack-plugin来实现自动化多页面配置。需注意的一点是多入口文件的位置要有相同的约束规定，才能正则匹配。 //多页面自动化配置const glob = require('glob');const setMPA = ()=&gt;{ const entry = {}; const htmlwebpackplugins = []; //使用glob库来类似linux下文件的通配匹配的方式获取每个模块的入口文件的路径。 const entryFiles = glob.sync(path.join(__dirname,'./src/*/index.js')); entryFiles.map((file)=&gt;{ let match = file.match(/src\\/(.*)\\/index\\.js/); //(.*)贪婪模式匹配任意字符 let pageName = match &amp;&amp; match[1]; //获取第二个子表达式里面的匹配值 entry[pageName] = file; htmlwebpackplugins.push( new HtmlWebpackPlugin({ template:path.join(__dirname,'src/index.html'), filename:`${pageName}.html`, chunks:[pageName], //针对多入口文件,就是选择要html嵌入的js文件 inject:true, //放置js文件的位置，如果设置为 true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部，'head' 将放置到 head 元素中。false则不会引入。 minify:{ html5:true, collapseWhitespace:true,//去除空格换行符 removeComments:true,//是否去除注释 minifyCSS:true, //压缩一开始就内联在 html 里面的css和js minifyJS:true, preserveLineBreaks:false } }), ) }); return { entry, htmlwebpackplugins }}const {entry,htmlwebpackplugins} = setMPA(); source-map信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。使用sourceMap来构建打包前后的代码之间的关联，因为打包前后的代码差异巨大，如果出现问题的话很难找到相应的位置，所以需要使用sourceMap来知道源文件错误的地方。至于其原理比较深奥，有兴趣搜一下阮一峰的大佬的文章。在webpack里面提供了许多模式，可以拆分组合，下面将一下基本构成的元素的含义。 ps：以下例子不管是开发环境还是生产环境都需要将mode设置为none，因为在特定环境下devtool指定了默认值,例如production的情况下，为了安全，是不能映射到真实文件的 eval：eval作用是让打包后的文件里面的每个模块代码都使用eval去执行，并且会追加//@ sourceURL（原始文件的url）。可能因为 eval 中为字符串形式，所以当源码变动的时候进行字符串处理会提升 rebuild 的速度，所以所有带有 eval 的选项，rebuild 速度都很快。 devtool : 'eval'//打包后的文件({ 8: function (module, exports) { eval('/*\\r\\n * @Description: \\r\\n * @Autor: cn\\r\\n * @Date: 2020-02-22 10:39:35\\r\\n * @LastEditors: cn\\r\\n * @LastEditTime: 2020-02-22 10:39:35\\r\\n */\\nconsole.log(\"search\");\\n\\n//# sourceURL=webpack:///./src/search/index.js?') //生成了sourceURL=webpack:///./src/search/index.js就可以知道原始文件 }}); source-map：顾名思义会生成一个.map文件，来关联源文件跟打包后的文件。 //# sourceMappingURL=index.js.map 打包后的文件底部会指定其sourcemap文件--------------------------------------------------------------------------------//source-map 文件简介{ \"version\": 3, //Source map的版本，目前为3。 \"file\": \"./static/js/index.js\", //转换后的文件名 \"sources\": [ //转换前的文件。该项是一个数组，表示可能存在多个文件合并。 \"webpack:///webpack/bootstrap\", \"webpack:///./src/index/index.js\" ], \"mappings\": \"AAAA\",//记录位置信息的字符串 \"sourceRoot\": \"\" //转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。} inline ： inline 的含义就是不产生独立的 .map 文件，而把 source-map 的内容以 dataURI的方式追加到 bundle 件末尾。这样会使得文件打包后变得比较大。 //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9... cheap：忽略列的信息，只定位到某一行。提升了构建速度。 module：包含了loader模块之间的sourcemap，因为webpack最终会将所有的非js资源，通过loader的形式转变成js资源。比如jsx语言的操作分为：jsx——（loader）——js——（压缩等处理）——压缩后的js。如果没有loader之间的sourcemap，那么在debug的时候定义到上图中的压缩前的js处，而不能追踪到jsx中。 不同环境下的较好搭配：首先，选择cheap，是因为我们只需要定位到某行就可以了，可以加快构建速度。而module就不用多说了，打包用到的loader之多，需要得到原始代码。而开发使用eval的原因是调试的时候重建的速度会快一些，生产不用是因为eval-source-map类似inline一样把map代码丢到eval语句里面,加大打包体积！ //在开发环境中我们使用：cheap-module-eval-source-map//在生产环境中我们使用：cheap-module-source-map。 提取公共资源抽取例如框架的依赖包，以及项目里面的通用模块等，减少打包后文件的体积。 使用html-webpack-externals-plugin插件，将通用库依赖通过cdn方式引入或者本地引入,抽离bundle。这个插件在htmlwebpackplugin后面实例化的话可以不用手动引入script，如果不是就得在html手动引入。 //基础库分离插件，将通用库依赖通过cdn或者本地引入,抽离bundlenew HtmlWebpackExternalsPlugin({ externals:[ { module:'react', entry:'https://11.url.cn/now/lib/16.2.0/react.min.js', global:'React' }, { module:'react-dom', entry:'https://11.url.cn/now/lib/16.2.0/react-dom.min.js', global:'ReactDOM' } ]}) 使用webpack4内置的splitChunksPlugin可以自定义抽离模块，包括项目通用的模块。 optimization:{ splitChunks:{ chunks:'all',// async：异步引入的库进行分离（默认）， initial： 同步引入的库进行分离， all：所有引入的库进行分离（推荐） minSize:0, //压缩前的模块的最小大小,默认0 minChunks:1, //最小被引用的次数,默认1 maxAsyncRequests:1, //最大的按需加载的次数,默认是1,跟maxInitialRequests道理应该一样,可是不论设置多少都是有多少个打多少个。待求证... /*入口文件做代码分割最多能分成3个js文件，默认是1,例如index，默认1的只打包生成index_hash文件,现在要将引入的react/react-dom等依赖包打成一个js,还有将引用次数超过2的模块抽成一个common 就得3*/ maxInitialRequests:3, name:true, cacheGroups:{ //cacheGroup默认基础上面的配置，可以覆盖 vendors:{ test: /[\\\\/]node_modules[\\\\/]/, //匹配node_modules下的依赖包 priority: -10,////值越大,优先级越高.模块先打包到优先级高的组里 name:'vendors' }, commons:{ name:'commons', minChunks:2, reuseExistingChunk: true //如果一个模块已经被打包过了,那么再打包时就忽略这个上模块 } } }}`","link":"/2020/03/20/webpack4/webpack4-base4/"},{"title":"webpack进阶使用(下)","text":"treeShaking-摇树优化使用CJS的时候，为了使用一个模块中的方法引入一个模块，整个模块都会最后打包到bundle里面。而在wepack4对其进行了优化，在mode指定为production的时候默认开启three shaking。注意只能检测静态引用，也就是ES6的import，export 语法。CJS则无法检测。而tree shaking是DCE的一种方式，检测的依据是代码不会被执行的，也就是没有引入的则会标记删除，或者执行的结果不会被用到的、执行的影响只是影响死变量也会被标记删除。这样的好处显而易见，可以减少打包后的代码的体积，减少程序的执行时间等… scopeHoisting-作用域提升webpack打包出来的是一个IIFE（立即执行函数，同时也是一个匿名闭包），传入的modules是个数组，数组每一个都是一个模块初始化函数（也就是我们自己定义导入导出的模块）。当项目庞大的时候，就会生成很多函数包裹块，增加内存的开销。而scope hoisting可以理解为是把每个模块被webpack处理成的模块初始化函数整理到一个统一的包裹函数里，也就是把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码，从每个模块有一个包裹函数变成只有一个包裹函数包裹所有的模块，但是有一个前提就是，当模块的引用次数大于1时，比如被引用了两次或以上，那么这个效果会无效，也就是被引用多次的模块在被webpack处理后，会被独立的包裹函数所包裹。这个很好理解，被多次引用的话，肯定是抽离成为一个模块更加方便。 //举个例子，没有使用scope hoisting,index文件里import两个模块,打包后的index文件是这样子的,两个函数作用域(function(module, __webpack_exports__, __webpack_require__) {\"use strict\";__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hello\", function() { return hello; });function hello() { return 'hellos';}/***/ }),/* 14 *//***/ (function(module, __webpack_exports__, __webpack_require__) {\"use strict\";__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"square\", function() { return square; });function square(x) { return x * x;}/***/ }), 设置mode为none的时候 设置 new webpack.optimize.ModuleConcatenationPlugin(),作用就是开启scopeHoisting/***/ 13:/***/ (function(module, __webpack_exports__, __webpack_require__) {\"use strict\";__webpack_require__.r(__webpack_exports__);// EXTERNAL MODULE: ./node_modules/react/index.jsvar react = __webpack_require__(0);var react_default = /*#__PURE__*/__webpack_require__.n(react);// EXTERNAL MODULE: ./node_modules/react-dom/index.jsvar react_dom = __webpack_require__(5);var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);// EXTERNAL MODULE: ./src/index/style.cssvar style = __webpack_require__(11);// CONCATENATED MODULE: ./src/index/hello.jsfunction hello() { return 'hellos';}// CONCATENATED MODULE: ./src/commons/util.jsfunction square(x) { return x * x;} 打包组件/基础库webpack还可以用来打包组件或者基础库(发布到npm上),举个简单例子。 //config.jsconst path = require('path');const webpack =require('webpack');const TerserPlugin = require('terser-webpack-plugin');module.exports = { entry:{ \"long-number\":'./src/index.js', \"long-number.min\":'./src/index.js', }, output:{ path:path.join(__dirname,'dist'), filename:\"[name].js\", library:\"longNumber\", //指定库的全局变量 libraryTarget:'umd', //支持库的引入方式 umd表示支持CJS ESM AMD方式、全局变量 libraryExport:'default' // 没有声明是default的话,打包后被包裹了一层对象，对象下的default才是我们export的 //Module {default: {…}, __esModule: true, Symbol(Symbol.toStringTag): \"Module\"} }, mode:'none', optimization:{ minimize:true, minimizer:[ //自定义需要压缩的文件,wp4后抛弃了UglifyJsPlugin，UglifyJsPlugin内部其实也是用了这个插件 new TerserPlugin({ include:/\\.min\\.js$/ }) ] } }//src/index.jsfunction add (num1,num2){ let a = String.prototype.split.call(num1,\"\"); let b = String.prototype.split.call(num2,\"\"); let res = []; let addOne = 0; //进位数 //以两个数最长的那位为标准 while(a.length||b.length){ let item1 = parseInt(a.pop())||0; let item2 = parseInt(b.pop())||0; let temp = item1+item2+addOne; if(temp&gt;9){ temp = temp%10; addOne = 1; }else{ addOne = 0; } res.unshift(temp) //每次都从头插入 } if(addOne){res.unshift(1)} //当最后相加要进位的时候 return res.join('');}export default {add}//最后npm登录后 publish上去在其他地方可以import 使用,且全局的话会有个longNumber变量，可以在引入script标签使用 命令行构建信息的优化通过配置stats来决定构建后输出的内容及声明时候会输出。一般情况下配置项都是&quot;errors-only&quot;,在发生错误的时候才输出。但是在每次构建成功或者警告的时候就没有内容了，这时可以搭配friendly-errors-webpack-plugin来友好的显示构建的内容。","link":"/2020/03/24/webpack4/webpack4-base5/"},{"title":"webpack4优化策略","text":"速度分析与体积分析webpack虽然内置了stats对象可以看到每次打包后的结果（输出的一大串），但是内容虽多但是难看明白。所以得借助其他插件来使得能明显的看到哪个环节（哪个loader/plugin）的耗时，直观的看到打包后那些模块所占的体积的比例，才能进行相关内容的优化与提速。 const SpeedMeasureWebpackPlugin = require('speed-measure-webpack-plugin'); //速度分析插件const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;//体积分析插件const smp = new SpeedMeasureWebpackPlugin();module.exports = smp.wrap({plugins:[ new BundleAnalyzerPlugin();]})//SpeedMeasureWebpackPlugin会详细的输出每个loader plugin的耗时SMP ⏱ PluginsHtmlWebpackPlugin took 1.57 secsOptimizeCssAssetsWebpackPlugin took 0.227 secsBundleAnalyzerPlugin took 0.148 secsCleanWebpackPlugin took 0.01 secsMiniCssExtractPlugin took 0 secsSMP ⏱ Loadersmodules with no loaders took 1.28 secsmodule count = 16//BundleAnalyzerPlugin则会在打包后打开一个8888端口来展示打包后模块的体积比例 使用多进程构建与多进程压缩代码由于node.js的单进程单线程的性质，在耗时的loader解析的时候，可以开启多进程的方式加快构建，在最后构建完成压缩阶段也可以开启多进程的方式加快压缩效率。 //在耗时的loader上使用才是最好的module.exports = {module:{ rules:[ { test:/\\.js$/, use: [ { loader: \"thread-loader\", // 有同样配置的 loader 会共享一个 worker 池(worker pool) options: { // 产生的 worker 的数量，默认是 cpu 的核心数 workers: 2, // 一个 worker 进程中并行执行工作的数量 // 默认为 20 workerParallelJobs: 50, } }, \"babel-loader\" ] },}optimization:{ minimize:true, minimizer:[ new TerserPlugin({ //自定义需要压缩的文件,wp4后抛弃了UglifyJsPlugin，UglifyJsPlugin内部其实也是用了这个插件 parallel:true //开启多进程压缩 }) ] } } 预编译资源模块分离(DLL优化)将一些第三方库，先进行预编译打包成一个固定的库，同时生成一个json文件，记录相关内容信息，同时再主配置文件进行关联，就能进行相关模块引用。但在webpack4后，对dll的应用就不是很多了，因为有了splitchunk进行分包处理，还有hard-source-webpack-plugin 缓存来提升了构建速度。但是dll对于一个团队而言，特别采用相同的技术栈，要么 react、要么vue 等等。这个时候，通常的做法都是把公共框架打成一个 common bundle 文件供所有项目使用。比如将 react、react-dom、redux、react-redux 等等打包成一个公共库。dll 可以很好的满足这种场景。 /*webpack.dll.js*/ const webpack = require('webpack');const path = require('path');module.exports = { entry:{ //可以配置多个key,例如还有其他的公共模块等 vender:[ 'react', 'react-dom' ] }, output:{ path:path.join(__dirname,'dll'), filename:\"[name].js\", library:\"[name]_dll\" //暴露的库的名字,这个必须跟下面的json的name一致,不然就会出现找不到预编译的库的情况 }, mode:'production', plugins:[ new webpack.DllPlugin({ name:'[name]_dll', //json文件里面name的值 path:path.join(__dirname,'dll/[name].json'), }) ]}/*webpack.prod.js*/plugins:[ new webpack.DllReferencePlugin({ manifest:require('./dll/vender.json') }), //可以手动引入vender.js文件 或者通过这个插件引入静态资源文件 new AddAssetHtmlPlugin({ filepath: path.resolve(__dirname, './dll/vender.js') })] 使用缓存来提升二次构建速度在耗时的loader例如babel-loader开启缓存形式，在构建模块转化阶段使用hard-source-webpack-plugin开启缓存，在压缩阶段开启压缩缓存。都能提升二次构建的速度。开启缓存后能在node_modules目录下的.cache看到相关缓存文件。 { test:/\\.js$/, use:['babel-loader?cacheDirectory=true'], //开启babel-loader 的cache exclude: /node_modules/ }, optimization:{ minimize:true, minimizer:[ new TerserPlugin({ //自定义需要压缩的文件,wp4后抛弃了UglifyJsPlugin，UglifyJsPlugin内部其实也是用了这个插件 parallel:true, //开启多进程压缩 cache:true //开启压缩缓存,指定mode为production的时候会自动开启 }) ] } //使用hard-source-webpack-plugin插件来提供模块转换的阶段缓存plugins:[ new HardSourceWebpakPlugin()] 缩小构建目标来加快构建速度 在rules规则匹配的时候通过配置exclude来决定那些需目录不需要被搜索匹配，例如node_modules 使用reslove自定义配置模块如何解析 module.exports={ resolve:{ //创建模块的别名，可以方便引入同时可以告知webpack引入模块的时候可以直接通过路径去寻找而不用一直查找。另外可以配置自己组件模块引入的方式，简化引入时候路径的长度。 alias:{ react:path.resolve(__dirname,'./node_modules/react/umd/react.production.min.js') }, //配置当找不到模块的时候搜索的目录，默认是跟Node.js一样会先查找当前目录的以及父级目录的 （node_modules）一直往上找 modules:[path.resolve(__dirname,\"node_modules\")], extensions:['.js'], //自动解析的扩展名称,表示在引入文件的时候可以不用写后缀,默认是js/json mainFields:['main'],//自定义当从npm包中导入模块时候，从package.json中使用哪个字段导入模块，及哪个是模块的入口文件，默认是[\"browser\", \"module\", \"main\"] }}","link":"/2020/03/24/webpack4/webpack4-base6/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"二叉搜索树","slug":"二叉搜索树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"查找","slug":"查找","link":"/tags/%E6%9F%A5%E6%89%BE/"},{"name":"css3","slug":"css3","link":"/tags/css3/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"pattern","slug":"pattern","link":"/categories/pattern/"},{"name":"面试题","slug":"面试题","link":"/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","link":"/categories/%E5%89%91%E6%8C%87offer/"},{"name":"css3","slug":"css3","link":"/categories/css3/"},{"name":"webpack4","slug":"webpack4","link":"/categories/webpack4/"}]}