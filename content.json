{"pages":[{"title":"算法相关整理","text":"作者: cn97 正在努力的人 以下整理的知识点是自己学习或者开发过程中积累的(当然有参考他人的博客文档等,不喜勿喷),学习中成长! 设计模式 创建型模式 单例模式 工厂模式 抽象模式 结构型模式 适配器模式 代理模式 桥接模式 行为型模式 命令模式 策略模式 模板模式 责任链模式 备忘录模式 迭代器模式 观察者模式","link":"/algorithm/index.html"},{"title":"前端内容整理","text":"作者: cn97 正在努力的人 以下整理的知识点是自己学习或者开发过程中积累的(当然有参考他人的博客文档等,不喜勿喷),学习中成长! JS相关 JavaScript [基础] JavaScript基础集合(一) [基础] JavaScript基础集合(二) ES6 [扩展] ES6知识点(一) [promise] ES6知识点(二) [class] ES6知识点(三)UI相关 CSS3 [基础] css需记点(一) [适配] css需记点(二) 预处理器 构建化工具 WebPack4 [概念] 配置文件及其相关概念 [配置] 基本配置 [进阶] 进阶使用 [优化] 相关的优化策略","link":"/bigweb/index.html"}],"posts":[{"title":"javaScript基础知识(上)","text":"👇内容速览👇 基本的数据类型及判断区别 闭包的一些问题 浅拷贝与深拷贝的区别跟实现 原型与原型对象 基本的数据类型及判断区别​ JS在ES6出现之前就只有以下几个数据类型：Number、String、Boolean、Undefined、Null、Function、Object。null只能自己手动赋值，而undefined当声明了变量没有赋值的时候，默认会赋值为undefined 。null也是对象。 基本数据类型：Number、String、Boolean、Undefined、Null 引用类型：Function、Object ​ 判断类型常用的方法是 typeof 操作符、instanceof操作符、Object.prototype.toString.call方法。三者的区别是： ① typeof：能判断基本的数据类型,除了null，在判别是否是Array的时候也不能判别出来，都会返回是object。 ② instanceof：不能判别基本的数据类型，但能判别对象（具体是哪个类），通过原型链判断。 ③ Object.prototype.toString.call：也是只能判别基本的数据类型，无法识别具体是哪个对象。 function A(){ return}var B = null;var c ;var D = new A();var E = { name:\"cn\",} //typeofconsole.log(typeof A) // functionconsole.log(typeof B) // objectconsole.log(typeof C) // undefinedconsole.log(typeof D) // objectconsole.log(typeof E) // object//instanceofconsole.log(A instanceof Function) // trueconsole.log(D instanceof A) // trueconsole.log(E instanceof A) // falseconsole.log(E instanceof Object) // true//Object.prototype.toString.call()console.log(Object.prototype.toString.call(A)) // [object Function]console.log(Object.prototype.toString.call(B)) // [object Null]console.log(Object.prototype.toString.call(c)) // [object Undefined]console.log(Object.prototype.toString.call(D)) // [object Object] 闭包的一些问题​ 何为闭包？闭包就是能突破作用域链，能读取到函数内部的变量，即如果一个函数会在父级返回后留住对父级作用域的连接的话，相应的闭包就会被创建。其实函数本身就是一个闭包！ //#1 将返回值赋值给另外一个全局变量，从而生成一个可以访问函数私有空间的函数。var a=\"global\";var F=function(){ var b=\"local\"; var N=function(){ var c=\"inner\"; return b; }; return N;};var inner=F();inner();//local 通过这样将N升级为全局变量，因为N可以访问F里面的变量，所以inner可以访问到b；//#2，声明一个全局占位符，实质是将N升级为全局变量。var inner;var F=function(){ var b=\"local\"; var N=function(){ return b; }; inner=N;}inner();// local 闭包好处就是能让我们访问到函数作用域里面的变量，可以用来封装私有变量。但有时候因为闭包也带来了一些不想要的结果。 //#3因为闭包可能出现的错误function F(){ var arr=[],i; for(i=0;i&lt;3;i++){ arr[i]=function(){ return i; }; }return arr;}var arr=F();//arr[0]() 3 arr[1]() 3 arr[2]() 3出现这个问题是因为这里创建了三个闭包，他们都指向了共同的变量i,它们拥有的是相关域在创建是的一个引用。//解决方法：1.立即执行函数 for(i=0;i&lt;3;i++){ arr[i]=(function (x){ return x; })(i); }return arr; }2.赋值给局部变量function F(){function binder(x){ return function(){ return x; };} var arr=[],i; for(i=0;i&lt;3;i++){ arr[i]=binder(i); }return arr;}//两种方法的实质都是将共同的变量变成自己的局部变量3. 使用ES6的 letfunction F(){ var arr=[]; for(let i=0;i&lt;3;i++){ arr[i]=function(){ return i; }; }return arr;} 浅拷贝与深拷贝的区别跟实现 对于引用类型，浅拷贝只是复制了对象在堆里面的引用地址，如果修改了其值，其他一起引用到这个对象的值也会受到影响。而如果想实现两个对象之间互不影响，就需要实现深拷贝，深拷贝是开辟了一个新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 浅拷贝就不多说了，深拷贝有以下几种方法： 如果只是拷贝一层对象的话就可以使用ES6提供的Object.assign() var obj1={a:1,b:2};var obj2=Object.assign({},obj1);obj1.a=4;console.log(obj2);//{a: 1, b: 2} 想简单粗暴就使用JSON实现 var obj1={a:10,b:{c:[1,2,3]}};var obj2=JSON.parse(JSON.stringify(obj1));obj2.b.c[0]=2;console.log(obj1);//{a:10,b:{c:[1,2,3]}}console.log(obj2);//{a:10,b:{c:[2,2,3]}} 最直接就是递归实现 function deepCopy(p,c){ c=c||{}; for(var i in p){ if(typeof p[i]==='object'){ //数组也得深拷贝一份 c[i]=Array.isArray(p[i])?p[i].splice():{}; deepcopy(p[i],c[i]); }else{ c[i]=p[i]; } } return c} lodash库提供的方法 var _=require('lodash');var obj1={a:10,b:{c:[1,2,3]}};var obj2=_.cloneDeep(obj); 原型与原型对象​ 原型（proto）跟原型对象（prototype）一开始小编也是晕晕，搞了大半天才明白是什么。个人习惯这样叫比较容易分清楚。其实归咎就是一句话，原型是每个对象都会有的属性，它是一个隐式指针，指向了创建这个对象的构造器函数的原型对象。原型对象就只有函数才拥有。又因为函数也是对象（也是通过new Function出来的，我们平时写的都是函数字面量），所以它本身拥有了两个属性，即上面的原型跟原型对象。 function A(){ this.name=\"cn\"; this.age=\"18\";}var obj=new A();console.log(obj.__proto__==A.prototype);//true 这时候就得插个题外话啦，在ES6之前，是没有class这个语法糖的，所有的对象都是通过构造器函数创建的。 //new 一个对象的过程function A(){ this.name=\"cn\"; this.age=\"18\";}var obj=new A();当new 一个实例对象的时候，其实大致发生了这样的事情：1.首先创建了一个空对象 var obj={};2.将这个对象的原型指向这个构造器函数的原型对象，实现共享方法的继承obj.__proto__=A.prototype;3.使用call/apply将构造器函数里面的this指向改变成为objA.call(obj)4.构造器函数最终返回this，就是我们的new的实例对象 ​ 构造器函数里面的属性是实例的属性，是属于每个实例对象的，而每个实例对象都会有共有的属性，那就是原型对象上的。 function Gadget(name,color){ this.name=name; this.color=color;}Gadget.prototype.pirce=100;var newtoy=new Gadget('cn','blue');newtoy.name //\"cn\"newtoy.price //100/*当我们访问price属性的时候，JavaScript引擎首先查询newtoy对象的所有属性，如果找到，就返回，但如果找不到，就会去查询用于创建当前对象的构造器函数的原型，即访问newtoy.constructor.prototype 找到就返回。再找不到就顺者原型链找下去，直到找到Object*/","link":"/2020/03/09/javascript/javaScript-base-1/"},{"title":"ES6知识点(一)","text":"👇内容速览👇 一些新特性跟拓展 箭头函数特点及与普通函数的区别 Symbol数据类型 一些新特性跟拓展 const / Let 为了弥补js没有块级作用域的缺陷，引入了let块级变量声明。同时也引入了const 常量。其使用跟其他语言一样，只是需要注意以下以下几点： let跟const所声明的变量只在所在的代码块里面才有效，不存在变量提升，且不能重复声明，const在声明后必须初始化，否则会报错。 { var a=100; console.log(b); //出错！ const b=200; let c=50;}console.log(a); //100console.log(b); //出错！console.log(c); //出错！ ES6中，var、function声明的全局变量是作为window 的属性，而let、const、class声明的全局变量则是在Script对象上。 var a=100;const b=200;let c=50;console.log(window.a);//100console.log(window.b);//undefined//ps：具体可以通过谷歌浏览器开发者模式查看Scope可以看到 模板字符串 以往ES5输出字符串都是通过+号拼接的，十分麻烦，字符串还不支持换行。ES6里面的模板字符串是使用``来声明的，里面的变量则是用${item}来表示，跟那些模板引擎功能有点类似。 //ES5下$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!');//模板字符串$('#result').append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; //嵌入变量 are on sale!`);/*当模板字符串表示多行字符串的时候，所有的空格和缩进都会被保留到输出中，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。*/$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 扩展运算符跟双冒号运算符 ES6使用扩展运算符可以来展开数组或者对象，也可以用来给对象或者数组添加属性。而双冒号运算符是用来绑定函数的this指针的指向。 //扩展运算符展开数组/对象var a=[1,2,3];var b={name:\"cn\",age:12};var c={...b}console.log(...a); //1 2 3console.log(c); //{name: \"cn\", age: 12}//添加数组/对象属性var a=[1,2,3];var b=[4,5,...a];var c={name:\"cn\",age:12};var d={sex:\"man\",...c}console.log(b);//[4, 5, 1, 2, 3] console.log(d);//{sex: \"man\", name: \"cn\", age: 12}/*双冒号运算符::左边是一个对象，右边是一个函数，运算符自动将左边的对象（作为this）绑定到右边函数上类似于call/apply/bind的作用,得用babel转码才能实现*/foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); for…of、for…in和forEach、map区别 for-of：具有迭代器接口，可以遍历数组，类数组，set和map集和等等部署了迭代器接口的。不能遍历普通对象，可以中断。 for-in：遍历对象自身跟继承的可枚举的属性，即获取的是键值或者下标，可以中断。 forEach:只能遍历数组，不能中断，没有返回值。 map:只能遍历数组，不能中断，返回的是修改后的数组。 箭头函数特点及与普通函数的区别 在ES6之前，函数内部的this是指向谁调用了这个函数这个this就是指向谁的，当在一些回调函数里面，就可能出现想访问某些对象的属性的时候，this指向不是这个对象，导致访问不了，解决的方法一个是通过call,apply等方法改变this的指向，要么就一开始将this赋值给that,让作用域链来访问。可以通过使用箭头函数来解决这些繁琐的步骤。因为箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。即this是继承自父的执行上下文。话不多说，看代码就知道了。 var rules=1; var Empt={ rules:2, click:()=&gt;{ console.log(this.rules); }};function Button(){ this.rules=3; this.click=()=&gt;{ console.log(this.rules); };} Empt.click(); /* 1 箭头函数在创建时确定this的指向， 因为click箭头函数是作为对象字面量的属性定义， 对象字面量在全局定义，所以this 指向全局 */ var button=new Button(); button.click(); /*3 箭头函数作为新建对象的属性， Button函数this指向新建对象， 所以this指向新建对象 */ Symbol数据类型 在ES6引入的一种新的基本的数据类型，表示独一无二的的值，可以用来作为常量，或者定义私有变量。Symbol只能通过Symbol函数生成。因为它是一种基本的数据类型，所以在使用typeof检查的时候，返回的是’symbol’。且因为是独一无二的，所以比较两个symbol实例的时候，往往都是返回false。 作为对象属性名：用于保证不会出现同名的属性，还可以定义常量。注意！symbol值作为对象的属性名时，不能用点运算符，因为点号后面跟的是一个字符串，不是一个symbol值。 let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = 'Hello!';// 第二种写法let a = { [mySymbol]: 'Hello!' //常用}; 属性名的遍历：Symbol类型的key是不能通过Object.keys()或者for...in来枚举的，它未被包含在对象自身的属性名集合(property names)之中，只能用Object.getOwnPropertySymbols方法获取指定对象的所有Symbol属性名。或者用Reflect.ownKeys`方法返回所有类型的键名。 const obj = {};let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 全局的symbol：如果想共享同一个symbol，这时候就可以使用Symbol.for()方法。该方法跟Symbol方法类似，只不过这个方法接受一个参数，当有这样的一个Symbol值，则返回，否则则新建一个以该字符串为名称的Symbol值。","link":"/2020/03/12/es6/es6-base-1/"},{"title":"桥接模式","text":"一、桥接模式及其应用桥接模式，将抽象部分跟具体实现部分分离，两者可以独立变化，也可以一起工作。中间通过‘桥’连接。如经常用到的组件上的那些方法，它们接受一个函数，如果用户传入这个函数，那么就会在某段代码逻辑里面使用。这个过程中，组件就是桥的作用，而用户传入的函数则是具体实现的部分了。 二、代码实现//例如array对象上的forEach方法，就是桥接模式的应用,forEach就是抽象部分，而具体实现是用户传入的回调函数。const forEach=(arr,callback)=&gt;{ if(!Array.isArray(arr)) return; const length=arr.length; for(let i=0;i&lt;length,i++){ callback(arr[i],i); }}let arr=[\"a\",\"b\"];forEach(arr,(el,index)=&gt;{ console.log(el+index);})","link":"/2020/03/13/pattern/bridging-pattern/"},{"title":"抽象工厂模式","text":"一、抽象工厂模式及其用途抽象工厂模式，其实就是在工厂模式的基础上，对工厂类再次抽象封装，产生一个超级工厂类。这个超级工厂类同时可以用一个抽象工厂类对子类工厂进行约束，超级工厂创建的是一个类簇，类簇里面才是相应的对象实例。 二、代码实现抽象工厂类制定约束构建一个抽象工厂类来对工厂类的实现进行相应的约束 class AbstractFactory{ getPerson(){ throw new Error(\"子类请实现接口\"); } getAnimal(){ throw new Error(\"子类请实现接口\"); }} 创建实体类class Dog { name(){ console.log('狗'); }}class Cat { name(){ console.log('猫'); }}class Male { name(){ console.log('男人'); }}class Female { name(){ console.log('女人'); }} 创建各自的工厂类跟之前工厂类一样创造工厂来产出相应的实例，只不过这时候的工厂会受到抽象工厂类的约束 class PersonFactory extends AbstractFactory{ getPerson(person){ switch(person){ case:'male' return new Male(); case:'female' return new Female(); default: break; } } getAnimal(){ return null; }}class AminalFactory extends AbstractFactory{ getAnimal(name){ name=name.toLocaleLowerCase(); switch(name){ case:'dog' return new Dog(); case:'cat' return new Cat(); default: break; } } getPerson(){ return null; }} 超级工厂类的实现//超级工厂类，生产对应的工厂类簇class Factory { constructor(choice){ choice=choice.toLocaleLowerCase(); switch(choice){ case:'person return new PersonFactory(); case:'aminal' return new AminalFactory(); default: throw TypeError(\"class name wrong\"); } }}//创建person工厂类const personFactory =new Factory(\"person\");//创建male实例const male=personFactory.getPerson(\"male\");male.name()//'男人'","link":"/2020/03/13/pattern/abstractFactory-pattern/"},{"title":"适配器模式","text":"一、适配器模式及其用途“水管弯弯”适配器模式，顾名思义，它就是对数据进行适配，将一个类的接口（方法亦或是属性）转换/过滤/重组成为另外的接口来满足需求。但常用在两个接口构造类似的情况下，如若两个大相径庭，适配模式就有点力不从心了。 二、代码实现适配框架大名鼎鼎的Jquery 框架大家都很熟悉吧，假设现在有一内部框架A，其结构与Jquery很类似，但是提供的方法却比较少，想引入Jquery却不想影响到之前写的代码，可以这样做 A.g =function (id){ return document.getElementById(id);}window.A = jQuery;//适配器方法A.g = function (id){ return $('#'+id)[0]} 数据适配假设有这样的各大音乐平台提供的数据，为了后台好处理，我们需要对数据进行适配 const API={ QQ:()=&gt;({ n:\"最了不起的你\", a:\"火箭少女101段奥娟\", f:0 }), Netease:()=&gt;({ name:\"最了不起的你\", author:\"火箭少女101段奥娟\", free:false })}const adapter=(info)=&gt;{ return { name:info.name||info.n, author:info.author||info.a, free:info.free||info.f }}","link":"/2020/03/13/pattern/adapter-pattern/"},{"title":"命令模式","text":"一、命令模式 行为模式中的命令模式，是将可能请求的命令封装在一个对象中，交给中间人执行者，执行者再根据请求者的请求执行相应的命令。所以命令模式里面有三个主体。命令对象、执行者、请求者。应用场景就是当需要向命令对象发送请求的时候，不知道请求的对象具体是谁（执行者知道），更不知道被请求执行的操作是什么（命令对象知道），这个时候就用到命令模式了。优点就是高度松耦合，缺点嘛，就是需要定义三个对象且执行者跟命令对象之间的关系需要知道。 二、代码实现//定义一个命令对象，用来存储执行的操作const MenuBar = { refresh(){ console.log(\"执行了刷新操作\") }}//定义执行者函数，返回一个对象。用来执行命令const command = receiver=&gt;{ return { execute(){ receiver.refresh(); } }}//定义一个请求者,接受一个dom对象以及一个执行者const request = (button,command)=&gt;{ button.onclick=()=&gt;{ command.execute() } }}let refeshCommand = command(MenuBar);let button = document.xxxx;request(button,refeshCommand);","link":"/2020/03/13/pattern/command-pattern/"},{"title":"工厂模式","text":"一、工厂模式及其用途所谓工厂模式，就是根据不同的需求而”产出”相应的对象的类的实例，只对外提供一个根据不同参数来实例化相应的对象的函数。好处是在于可以避免了使用者于对象类之间的耦合，使用者完全可以不用知道这个类的细节，只需要懂得调用相应的方法。坏处也很明显，每个工厂只能”生产”同一类型的类的实例对象，当多类别对象的时候就不好用了，且当增加产品的时候需要更改判断的逻辑，繁琐 二、代码实现class Dog { run(){ console.log('狗'); }}class Cat { run(){ console.log('猫'); }}class Animal{ constructor(name){ name=name.toLocaleLowerCase(); switch(name){ case:'dog' return new Dog(); case:'cat' return new Cat(); default: throw TypeError(\"class name wrong\"); } }}const cat=new Animal(\"cat\");cat.run(); //狗","link":"/2020/03/13/pattern/factory-pattern/"},{"title":"代理模式","text":"一、代理模式及其用途代理模式，给原对象提供一个代理对象，代理对象拥有原对象的引用，可以通过访问这个代理对象来实现执行原对象的相关操作，进而能避免对原对象的直接访问。举个例子：如平常我们买车买房，自己亲自去找车主房主是不现实的，通常做法就是去找中介，代理对象就了类似与中介，拉起两者之间的桥梁。代理有虚拟代理跟保护代理，保护代理的话可以在代理中直接拒绝对真实对象的访问，而虚拟代理的话可以延迟访问到真正需要的时候，节省程序开销。所以优点是高度解耦，对象保护，缺点的话就是添加的代理对象，可能会开销增大。 二、代码实现/*----------------------------------------------------------------------保护代理*/ var Fans = { flower(){ Agent.reception(\"刀片\"); } } var Agent = { reception:function(gift){ console.log(\"粉丝送的:\"+gift); //粉丝送的:刀片 if(gift != \"花\"){ star.reception(\"花\"); } } } var star = { reception:function(gift){ console.log(\"收到粉丝的:\"+gift); //收到粉丝的:花 } } Fans.flower();/*----------------------------------------------------------------------虚拟代理*///代理模式实现图片的延迟加载const myImg={ setSrc(imgNode,src){ imgNode.src=src; }}const proxyImg={ setSrc(imgNode,src){ myImg.setSrc(imgNode,'./img.jpg'); //1. 加载占位图片 let img=new Img(); //2. 真正加载图片 img.src=src; img.onload=()=&gt;{ myImg.setSrc(imgNode,src); //3. 加载完成后，替换真正图片 } }}","link":"/2020/03/13/pattern/proxy-pattern/"},{"title":"观察者模式","text":"一、观察者模式及其用途 观察者模式，行为型模式的一种，当存在一对多的关系的时候，用观察者模式可以实现当这个被观察的对象被修改的时候，会自动的通知订阅它的其他依赖对象。例如angular 的一个依赖库RXJS就是广泛的应用了这种模式。但常常会与发布-订阅模式傻傻分不清楚。 二、代码实现 观察者模式：只有观察者跟被观察者，两者是直接通信的(松耦合) function Subject() { //被观察者 this.observers = []; this.state = '快乐';}Subject.prototype.attach = function (observer) { this.observers.push(observer);}Subject.prototype.setState = function (state) { this.state = state; this.notify();}Subject.prototype.notify = function () { //被观察者状态改变的话是直接与观察者通讯 this.observers.forEach(function (observer) { observer.update(); })}function Observer(name,target){ // 观察者 一般会有一个方法 this.name = name; this.target = target;}Observer.prototype.update = function () { // 更新方法 console.log(`通知：${this.name} 当前的状态是 ${this.target.state}赶紧哄`) }let subject = new Subject();let observer1 = new Observer('儿子', subject);let observer2 = new Observer('女儿', subject);subject.attach(observer1); // 给目标添加观察者subject.attach(observer2);subject.setState('开心') 发布-订阅模式:发布者跟订阅者两个互不知晓，而是通过一个中间人来传递信息(如读者与作者，中间人是报社，完全没耦合) /*这里的event 相当于报社中间人,而fn读者,通过报社订阅报纸,当作者有新的东西的时候,就会通过报社出版新的*/ function Event(){ this.events=[]; } Event.prototype.on=function(fn){ //订阅 this.events.push(fn); } Event.prototype.emit=function(data){ //发布 this.events.forEach(function(fn){ fn(data); }) } 所以两者的区别就是发送方与接收方是否是知晓对方存在的，观察者模式中,被观察者状态一旦发生改变，订阅它的所有观察者都会立即知晓。而订阅发布模式中,发布者与订阅者是不知道对方是谁的，而是通过中间人（例如event）来联系。","link":"/2020/03/13/pattern/observer-pattern/"},{"title":"单例模式","text":"一、单例模式及其用途所谓单例模式，就是一个类就只有一个实例，用途的话可以用来定义命名空间，通过在一个实例对象定义其的方法跟属性，来达到命名不重复的目的，例如Jquery的$符号就是这个思想。再者就是如果对于一个类是负责连接数据库的线程池，日志等逻辑的，用到这种模式来保证对象不被重复创建，降低开销。 二、代码实现//惰性单例模式var laztSingle=(function(){ //使用闭包使得单例对象为私有 var instance=null; function Signle(){ return { age:1 } } return function(){ if(!instance){ instance=new Signle() } return instance }})()var a=lazySingle();var b=lazySingle();console.log(a===b) //true","link":"/2020/03/13/pattern/single-pattern/"},{"title":"策略模式","text":"一、策略模式及其用途 行为型模式之策略模式，实质就是将一系列可以互换的算法封装起来，每组算法处理的业务是一样的，但是处理的过程跟结果是不一样的。根据用户需求选择其中一种。优点是能将算法的使用跟实现进行分离，并且可以添加相应的算法。缺点就是得知道每种策略算法是异同点才能选择。 二、代码实现//策略类，定义相关的策略算法const strategies={ A(){ console.log(\"A\"); } B(){ console.log(\"B\"); }}//环境类，就是选择算法工具const context=name=&gt;{ return strategies[name]} context('A')() //A","link":"/2020/03/13/pattern/strategy-pattern/"},{"title":"CSS3 常见知识(二)","text":"👇内容速览👇 各种像素的区别与理解 那些年遇到过的”视口” 移动端适配的一些小理解 各种像素的区别与理解 设备像素：设备像素，即物理像素、在设备出厂的时候就已经固化好了。 设备独立像素：逻辑像素，在缩放比例等于100%的时候，一个设备独立像素刚好就等于一个css像素。举个例子，在谷歌浏览器控制台切换到移动设备的时候所显示的。为什么又了物理像素还要引入这些像素来混淆呢。因为呀，在很多情况下，很多手机的屏幕尺寸不变，但是他的分辨率却提高了好几倍，导致了在相同尺寸不同分辨率的手机上，如果都按物理像素那样子计算的话，在低分辨率的手机上，能够撑满的内容，在高分辨率的手机上，往往会缩小好几倍。达不到我们想要的兼容效果。所以要引入一个新的单位来统一的计算。也就有了所谓的设备像素比（dpr）。 设备像素比：dpr =设备像素/设备独立像素，例如，iPhone6的设备像素比是2，即一个设备独立像素等于两个物理像素。 //在js获取window.devicePixelRatio//css 获取 当设备的dpr大于等于3的时候，字体显示红色@media (min-resolution: 3dppx) { body { color: red; }} 那些年遇到过的”视口” 布局视口：在pc浏览器上，布局视口等于浏览器的窗口大小，但不包括（border,margin,滚动条宽度）包括内容跟padding。在移动端，这个被默认的设置为980px,本意是为了让pc浏览器的页面能完整的显示在移动端，但是相应的页面就要进行缩小处理，进而此时css像素就不会等于设备独立像素。 视觉视口：用户在屏幕看到的真实区域，在pc浏览器上，视觉视口就是等于浏览器的窗口大小，但不包括（border,margin）但包括滚动条宽度。在移动端，这个被默认的设置为981px。用户缩放浏览器，不会改变布局视口，但是会改变视觉视口。 理想视口：谷歌浏览器调试移动端的到时候页面给的像素大小，像素单位是设备独立像素。 让css像素等于设备像素 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;/*width=device-width作用是将viewport宽度设置为设备独立像素的宽度-&gt;即布局视口等于理想视口。这时候css像素就与设备独立像素一一对应，此时的innerWidth就是设备独立像素的大小而不是980px了initial-scale 默认缩放比例，100%，如果改变的话比如width: 128px。css像素的大小是很容易变化的。当我们缩放页面的时候，元素的css像素数量不会改变，改变的只是每个css像素的大小。也就是说width: 128px的元素在缩放200%以后，宽度依然是128个css像素，只不过每个css像素的宽度和高度变为原来的两倍。如果原本元素宽度为128个设备独立像素，那么缩放200%以后元素宽度为256个设备独立像素（css像素宽度始终是128）放大的时候，视觉视口的大小即用户看到的大小就会变小，所以理想视口/视觉视口=设备独立像素/css像素=页面的缩放比例ps：可以设置禁止缩放来达到css像素与设备独立像素的1:1，但用户体验可能会不好*/ 浏览器的一些相关大小获取：当页面缩放比例为 100%时， CSS像素=设备独立像素，理想视口=视觉视口。 window.innerHeight：获取浏览器视觉视口高度（包括垂直滚动条）。 window.outerHeight：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。 window.screen.Height：获取获屏幕取理想视口高度，这个数值是固定的。 window.screen.availHeight：浏览器窗口可用的高度。 document.documentElement.clientHeight：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。 document.documentElement.offsetHeight：包括内边距、滚动条、边框和外边距。 document.documentElement.scrollHeight：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与 clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。 移动端适配的一些小理解 flexible方案：使用rem来布局，缺点计算比较繁琐，但是有插件可以支持 (function (win, doc) { if (!win.addEventListener) return; var html = document.documentElement; function setFont() { var cliWidth = html.clientWidth; var rem = clientWidth /10 html.style.fontSize = rem+'px' //将font-size设置为布局视口的1/10 } win.addEventListener('resize', setFont, false) doc.addEventListener('DOMContentLoaded', setFont, false)})(window, document); vw,vh 视口宽度视口高度百分比，将视口宽度跟视口高度分为100份，每份是1%。缺点是px转换为vw的时候不一定能整除。 解决1px适配问题：在设备像素比大于1的设备上，1px是被多个物理像素渲染。 /*使用伪类跟媒体查询*/.border_1px:before{ content:'', position:absolute; height:1px; width:100%; backgorund-color:#000; transform-origin:50% 0;}/*2倍屏*/@media only and screen(min-resolution: 2dppx) { .border_1px:before{ transform:scaleY(0.5) }}/*3倍屏*/@media only and screen(min-resolution: 3dppx) { .border_1px:before{ transform:scaleY(0.33) }}","link":"/2020/03/13/ui/css-base2/"},{"title":"CSS3 常见知识(一)","text":"👇内容速览👇 常见的几种居中方法 浮动与BFC 与浏览器性能相关 常见的几种居中方法 使用position定位及transform特性 &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt;&lt;/div&gt;.container{ position:relative;}.content{ position:absolute; top:50%; /*这两个百分比是相对父元素的*/ left:50%; transform:translate(-50%,-50%) /*这里的百分比是相对与本身的*/}/*或者*/.container{ position:relative;}.content{ position:absolute; left:0; top:0; right:0; bottom:0; /*让其自动分布*/ margin:auto} flex布局 .container{ display:flex; justify-content:center; align-items:center;} 使用伪元素 .container{ width:200px; height:200px; /*水平居中*/ text-align:center;} /*定义一个基线，垂直居中是需要一个行内元素的基线来作为标准的 :after出现的意义就是在于利用display:inline-block和height:100% 这俩属性完成行内与基线这俩个大前提要求 (即行内块元素，高度100%自然就以高度50%处即平常所说的中线为基线*/.container:before{ content:\"\"; display:inline-block; height:100%; vertical-align:middle;}.content{ display:inline-block; /*根据之前定义的基线进行对齐*/ vertical-align:middle;} 浮动与BFC 浮动：浮动基本就不说了，一些细节就是普通的元素与浮动元素一起后，会被浮动元素所遮挡，但是里面的文字却可以看到这个浮动元素，围绕在这个浮动元素的周围。浮动是对于所在的那一行的，声明为浮动的元素不管是内联还是块级元素，都会生成一个块级框，如果两个浮动元素因为放不下而导致了一个向下移动，可对下移的元素设置负外边距使其上移。 清除浮动的方法 伪元素清除浮动 .clearfloat:after{ content:''; display:block; height:0; visibility:hidden; clear:both;} 声明BFC清除浮动 .clearfloat{ overflow:auto;} BFC:块级格式上下文，规定了内部块级盒子的布局。float不为none，position为absolute、fixed，display为flex、inline-block的，overflow不为visible的都能产生BFC。特性跟作用如下： 特性：①属于一个BFC的两个相邻盒子之间的margin会出现重叠的情况。②BFC区域不会与浮动的区域发生交集，而是紧贴在浮动边缘。③BFC计算高度的时候把浮动元素也计算在里面，所以可以用来清除浮动 作用：①清除浮动，因为特性三。②解决外边距合并问题，属于同一个BFC的两个相邻的盒子外边距会重叠，将其中一个盒子display声明为inline-block。③制作自适应两栏布局，布局之间没有缝隙。 与浏览器性能相关 回流与重绘： 回流：当dom tree 与css rule tree 结合生成render tree后，需要计算在设备视图中的位置跟大小，这个过程就是回流。 重绘：在回流阶段后，得到了节点的大小，位置等几何信息，将其转换为屏幕的实际像素的过程，就是重绘。 引发回流重绘的原因： 页面一开始的渲染 dom节点位置、大小发生变化 添加/删除dom节点 浏览器尺寸发生变化 减少回流跟重绘：因为每次回流跟重绘都比较耗浏览器的性能，所以要尽量减少其次数，常见的方法就是批量修改dom，或者先将dom元素脱离文档流，修改完成后再带回文档。多修改class少使用style。 css文件的导入跟位置： 导入文件的时候link标签导入跟import 的区别 href：超文本链接，用来建立文档与元素的之间的链接，浏览器会识别当前是css文件，并行下载文档，不会阻塞一开始的加载过程。（多用） source：引入src所指向的内容，浏览器遇到该元素的时候，会停止对页面的渲染，转而去加载相应的资源，直到加载完成。（少用） 位置：css文件尽量放在head里面，因为css的加载过程中因为跟dom树生成是并行的，所以不会影响到dom树，但是会影响到最后的render树的生成，从而会影响到回流重绘。所以link标签最好是尽量放在head里面，因为dom树的解析是自上而下，这样可以加快render树的生成。","link":"/2020/03/13/ui/css-base1/"},{"title":"ES6知识点(三)","text":"👇内容速览👇 Generator函数 async/await Class语法 Generator函数 基本语法 与promise对象一样，同样是为了异步编程。ES6提出了Generator函数，Generator函数是一个状态机，内部封装了多个状态，返回结果是一个迭代器(Iterator)对象。与普通函数的区别在于function声明与函数名之间多了个星号。且函数内部能使用yield关键字（普通函数使用将报错）。🙋‍个例子 function * exampleGenerator(){ yield 'hello'; yield 'world'; return \"end\"}var g= exampleGenerator();//里面有三个状态,分别对应三个关键字后面的字符串 调用函数后，并不会执行，因为其返回的不是一个值，而是一个Iterator对象，必须是调用这个对象的next方法，将内部的指针从函数头部或者是上一次停留的地方向下移动，遇到yield/return就会停止下来，返回后面跟随的值，然后挂起，下次next再重复上面的步骤。 console.log(g.next());/*{value: \"hello\", done: false}value表示当前的值，done 则表示遍历是否结束*/console.log(g.next());//{value: \"world\", done: false}console.log(g.next());//{value: \"end\", done: true} 带参数的next方法 因为yield方法并没有返回值，当我们下一个yield需要上参数的时候，这时候就只能通过next方法传参进去。next里面的参数表示的是上一个yield表达式的返回值,如果在另外一个表达式里面，必须放在圆括号里面。这个也是后面async函数内部实现的原理步骤之一。 function * exampleGenerator(x){ var y = yield (x+1) ; var z = yield (y*2); return x+y+z;}var g= exampleGenerator(2);console.log(g.next());//2+1=3 {value: 3, done: false}console.log(g.next(4));//4*2=8 {value: 8, done: false}console.log(g.next(5));//2+4+5=11 {value: 11, done: true}-----------------------------------//再看一个例子，会更加明白function * exampleGenerator(x){ var y = 2 * (yield(x+1) ); var z = yield (y*2); return x+y+z;}var g= exampleGenerator(2);console.log(g.next());// 2+1=3console.log(g.next(4));// 2*4*2=16console.log(g.next(5));// 2+2*4+5=15 自动遍历内部的值：使用for…of循环 因为for…of循环能遍历具有Iterator接口的，而generator函数返回的刚好是一个迭代器对象。无需调用next方法，适合那些不用传参计算的情况。注意：return 返回的值不包括在里面 function * exampleGenerator(){ yield 'hello'; yield 'world'; return \"end\"}var g= exampleGenerator();for(let item of g){ console.log(item);}// hello world yield* yield 语句后面如果想执行一个generator,使用yield*表达式。 function * firstGenerator(){ yield 'cn'; yield 'emmmm';}function * secondGenerator(){ yield 'hello'; yield 'world'; yield *firstGenerator() ;}var g= secondGenerator();for(let item of g){ console.log(item);}// hello world cn emmmm throw方法 定义在原型对象上的throw方法，每个由generator函数返回的迭代器对象，都会拥有，可以在函数体外部调用，用来抛出错误，优先被函数内部的try…catch捕获，如果内部没有try…catch的话，就被外部的try…catch捕获。如果内外都没有的话，就直接报错，中断执行。 注：g.throw与throw互不影响！ 被内部捕获的话，会顺带执行下一个yield表达式，且不会影响下面的执行,如果不是被内部捕获的，就不会继续执行下去，即使在外面有try…catch块。 #内部捕获function * exampleGenerator(){ try{ yield 'hello'; }catch(e){ console.log(e); } yield 'world'; yield 'emmm';}var g= exampleGenerator();console.log(g.next());console.log(g.throw('错误'));console.log(g.next());/*{value: \"hello\", done: false} 错误 {value: \"world\", done: false} {value: \"emmm\", done: false}*/#外部捕获function * exampleGenerator(){ yield 'hello'; yield 'world'; yield 'emmm';}var g= exampleGenerator(); console.log(g.next()); //hellotry{g.throw('错误')}catch(e){ console.log(e); //错误}console.log(g.next());//undefined async/await之前讲过的异步编程的方法，回调函数，嵌套多层的时候“回调地狱”问题难以处理。所以才有了Promise对象。但是当嵌套很多层的时候，一堆的return、then语句写到迷茫，代码可读性跟简洁性就会降低。而async/await则是用同步的思想来处理异步的操作，代码的可读性跟简洁性就会大大提高，它其实是由generator跟promise结合而成的。 用法 可以看成是generator函数的语法糖，将(*)替换成async，将yield 替换成await，且是自执行的，await后面跟的是一个promise对象或者其他类型的值都行，await有返回值，返回值就是后面跟着的那个。整个函数返回值也是一个promise对象。 console.log('start');var p1=new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(1); },1000)})var p2=(x)=&gt;{ return new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve(x); },1000) })}var a=async function(){ var a1= await p1; var a2= await p2(a1) return a1+a2}()a.then((data)=&gt;{ console.log(data);})console.log('end');// start end 2 由此可以看出异步函数虽然以同步的形式写的，但是并不会阻塞住，实质是遇到await的时候，会先让出执行栈，等到异步操作完成(这里就是promise对象resolve的时候)，再执行下面的操作，且可以将其返回值作为下一个异步操作的参数（这个在很多情况下很有用）。 通常情况下，如果await后面的promise对象变成了reject状态的话，整个函数将会中断执行。如果想不影响下面执行的话，就得在内部进行异常捕获。 var a=async function(){ try { await Promise.reject('hhh'); } catch (error) { console.log(error); } var a1= await 'hehehe' return a1}()a.then((data)=&gt;{ console.log(data);})//hhh hehehe 实现原理 前面说到，async 可以由generator函数+promise对象来实现，👇下面是实现思路 function getCountry(url){ return new Promise((resolve,reject)=&gt;{ resolve(\"中国\"); })}function getCity(country){ return new Promise((resolve,reject)=&gt;{ resolve(\"潮州\"); })}function getProvince(country){ return new Promise((resolve,reject)=&gt;{ resolve(\"广东省\"); })}// 定义一个generator函数function * gen(){ //getCountry是一个异步操作 const country = yield getCountry(\"url\"); const province = yield getProvince (country); const city = yield getCity(province); return city}//自定义async函数function async (generator){ //返回一个迭代器对象 var interator = generator(); return new Promise((resolve,reject)=&gt;{ function handle (interatorResult){ console.log(interatorResult); /* 获取当前值 { value: Promise { '中国' }, done: false } { value: Promise { '广东省' }, done: false } { value: Promise { '潮州' }, done: false } { value: '潮州', done: true } */ const value=interatorResult.value; //到最后一个的时候就直接resolve出去 if(interatorResult.done){resolve(value)} if(value instanceof Promise){ value.then((res)=&gt;{ //递归调用，res作为上一个yield的返回值传递下去 handle(interator.next(res)) }).catch(e=&gt;{interator.throw(e)}) } } //启动调用 handle(interator.next()); })} async(gen).then(val=&gt;{ console.log(val);//潮州 }) Class语法在ES6之前，是没有class类与extends继承的概念的，所有的对象都是通过构造器函数创建的，继承也是通过原型链来实现，为了简便语法，更加面向对象，ES6引入了这两个“语法糖”。 Class 在类里面，实例的属性得显示的定义在this上。否则将被认为要定义在原型上，与ES5一样，实例的原型会指向类的原型对象上。 class Man { constructor(name){ this.name=name } getName(){ console.log(this.name); }}var man=new Man('cn');console.log(man.hasOwnProperty('name'));/* true 构造器里面定义的属性是在实例上的*/console.log(man.getName===Man.prototype.getName);console.log(man.hasOwnProperty('getName'));console.log(man.__proto__.hasOwnProperty('getName'));/* true false true 类里面声明的方法都是定义在类的原型对象上的。 实例的__proto__指向的是Class.prototype*/ getter/setter class里面也可以对对象属性的读取跟设置进行拦截修改，途径就是get / set 方法 class Man { constructor(){ } get name(){ return 'cn1997' } set name(value){ console.log('setter '+value); }}var man=new Man();man.name='cn'; // setter cnconsole.log(man.name); // cn1997 其他 class 内部方法的this默认是指向类的实例的，类不必函数，不存在变量提升，即不能在类声明之前创建一个实例对象。class.name属性将会返回类名…… 继承 ES5：对比ES5的继承一般都是寄生组合式，即实例属性使用构造器继承，而方法使用原型继承方法。 function A(){ this.name='a'}A.prototype.getName=function(){ return this.name;}function B(){ A.apply(this); //继承属性 this.age='12'}B.prototype=new A();console.log(B.portotype._proto_===A.prototype) //trueconsole.log(B._proto_===A)//false ES6的继承，根据阮一峰大佬的话来说，ES6的继承分两条链，一条是原型链，一条是原型对象的链。 子类的proto属性，表示构造器的继承，指向父类。跟ES5的不同之处。 子类的prototype属性的proto，表示方法的继承，指向父类的prototype，这一点与ES5的一致。 实例的指向就很明确了，根据所构造的类的关系去找。 class A{ constructor(){ this.name='cn'; } getName(){ return this.name; }}class B extends A{ constructor(){ super() }}var a=new A();var b=new B();console.log(a.__proto__===b.__proto__)//falseconsole.log(a.__proto__===b.__proto__.__proto__);//trueconsole.log(B.prototype.__proto__===A.prototype) //trueconsole.log(B.__proto__===A)//true 区别来了，ES6的继承，子类必须在构造器函数里面调用super方法，因为子类的this对象，必须先通过父类的构造函数塑造，得到父类的实例属性跟实例方法，而后在将其加工，加上子类的实例属性跟方法，总而言之，不调用super方法，子类得不到this对象。而ES5的继承，是先通过创建了一个子类的实例对象this，再将父类的方法跟属性添加到this上( A.apply(this) )。可以这样理解☞，之前我们知道new 一个实例的过程，先创建一个空对象，而ES6可能是创建的是一个父类的对象，所以super可能就是创建的一个父类的对象，再进行后续的操作….","link":"/2020/03/12/es6/es6-base-3/"},{"title":"ES6知识点(二)","text":"👇内容速览👇 Set、Map数据结构 Proxy(代理器) Promise对象 Set、Map数据结构 Set ​学过Java的话就会对这个数据结构很熟悉。它类似于数组，但是区别在于它的成员值只能是唯一的，也就是说，里面是没有重复的值。跟其他数据类型一样，都是由构造器函数Set本身来new生成相应的实例。它可以接受一个数组作为参数，所以可以用来进行数组的去重工作。 注意：Set没有键名，只有键值。或者说它的键值与键名是同一个！ //构造一个Set实例，接受一个数组作为参数const set=new Set([1,2,3,4]);//可以被for...of遍历。可以看到键值与键名是一样的for(let item of set.entries()){ console.log(item)}// [1,1] [2,2] [3,3] [4,4] Set 的四个操作方法 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 Set 的四个遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 WeakSet 与Set类似，但正如其名一样，它只是Set的弱类型，且成员只能是对象，对成员对象的引用是弱引用。弱引用就是对值的引用的不计入垃圾回收机制的引用次数的，很可能在某时刻被垃圾回收机制给回收掉。所以不能被遍历，因为值不知道什么时候会被回收了。但是因为这个特性，可以用来存放一组临时的对象，以及存放对象的相关信息，只要外部的引用消失，WeakSet对这个对象的引用也自动消失。以此减少内存泄漏。 const ws = new WeakSet();var a={dom:document.getElementById('root'),name:'cn'}ws.add(a);console.log(ws.has(a));//truea = nullconsole.log(ws.has(a));//false Map Map跟对象很类似，但是传统的对象的键名只能是字符串，这里的Map的键名可以是任何的类型，包括对象。同样的，也是通过构造器函数来初始化实例，可以接受一个参数，任何具有迭代器接口，且成员是一个双元素的数组的数据结构，都可以作为参数。 const map=new Map([['name','cn'],['age','20']]);console.log(map.size); //2console.log(map.get('name'));//cn//接受数组为参数，实际是执行了一下的代码var item=[['name','cn'],['age','20']];const map=new Map();item.forEach(([key,value])=&gt;{ map.set(key,value);}) 注意：同一个值的不同对象是被视为不同的键的。 Map的属性和方法 size 属性 返回成员总数。 set(key, value) 设值 get(key) 获取值 has(key) 查询 delete(key) 删除 clear() 清除所有成员 遍历方法类同Set WeakMap 与Map类似，但只接受对象作为键，键名对对象的引用是弱引用，其引用对象可以被垃圾回收，不能遍历。可以用来保存DOM节点。即如果想为对象添加相应的数据或者描述，又不想干扰垃圾回收机制，Map是很好的选择。 const wm = new WeakMap();const element = document.getElementById('root');wm.set(element, 'information');/*此时如果消除element的引用，则所占的内存将会被回收，Weakmap 保存的这个键值对，也会自动消失。*/-------------------------------------------------/*ps：下面是用 node模拟的一个环境,搜了不少都是说heapUsed值才是判断内存是否泄漏的标准，但是我这里的键值是一个数组，它的存储空间是在栈里面而不是堆，所以感觉看rss的占用可能是比较对吧（个人猜想，因为heapUsed的值就按照所想的值的顺序出现，有正确的 观点的欢迎在评论指出................）*/PS D:\\react\\server&gt; node --expose-gc&gt; global.gc();undefined&gt; process.memoryUsage();{ rss: 22376448, //所有内存占用 heapTotal: 6635520,//堆占用的内存 包括用到跟没用到的 heapUsed: 4548648,//用到的堆 external: 9625 }// V8引擎内部C++对象占用的内存&gt; let wm = new WeakMap();undefined&gt; let b = new Object();undefined&gt; global.gc();undefined&gt; process.memoryUsage();{ rss: 22044672, heapTotal: 7684096, heapUsed: 4830024, external: 8716 }&gt; wm.set(b, new Array(5*1024*1024));WeakMap {}&gt; global.gc();undefined&gt; process.memoryUsage();{ rss: 64049152, //set之后，内存占用明显变大 heapTotal: 49639424, heapUsed: 46702528, external: 8619 }&gt; b=null; //清除外部引用null&gt; global.gc();undefined&gt; process.memoryUsage();{ rss: 22102016, //内存大小恢复跟之前开始的差不多大小的值 heapTotal: 7684096, heapUsed: 4757064, external: 8682 }&gt; Proxy(代理器) ES6引入了proxy对象，用来在访问目标对象之前进行一些拦截操作，可以对外界的访问进行过滤跟改写。同样的，它也是有相应的构造器函数来构建实例。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象进行操作。 var proxy=new Proxy(target,handler)//其中target表示要拦截的对象，handler则是定义拦截的行为，也是一个对象Ps:如果handler为一个空对象，则w没有拦截效果，访问proxy就是访问target本身//对象的读取操作,使用get方法var person={ name:'cn'}var proxy=new Proxy(person,{ get:function (target,property){ if(property in target ){ return target[property] }else{ throw new Error('没有这个参数') } }});proxy.name //cnproxy.age //抛出异常 Proxy支持的拦截操作一共有13种，具体可以去看阮一峰大佬的文档👇 http://es6.ruanyifeng.com/#docs/proxy#Proxy Promise对象 以往的异步编程，往往都是通过事件+回调函数来实现，但是当回调嵌套很多层的时候，其代码的可读性跟维护难度都会大大增加，进而出现“回调地狱”这种情况。而promise对象，表示一个异步操作的最终状态(成功或者失败),可以将异步操作用“同步”的形式表示出来，从而解决了“回调地狱的问题”。 promise有三种状态：pending(进行中)、resolved-fulfilled(已成功)、 rejected(已失败),对象的状态不受外界影响。所以Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 基本用法 const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); }});promise.then((data)=&gt;{ console.log(data)}).catch(err=&gt;{ console.log(err)})/*如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的异常是不会传递到外层代码的。所以一般要实现catch方法，catch方法会返回一个promise对象，所以依旧可以调用then方法Promise 对象的错误具有“冒泡”性质，一直向后传递，直到被捕获为止。错误总是会被下一个catch语句捕获。所以catch一般写在最后*/ Promise.all() 将多个promise实例包装成一个新的promise对象，新的promise对象只有等到参数成员里面的所有成员的状态是fulfilled，它才会是fulfilled。如果成员中有定义了自己的catch方法，那么新的Promise实例的catch方法不会被触发 var promise1=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 2000);});var promise2=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 0);});Promise.all([promise1,promise2]).then((data)=&gt;{ console.log(data);})// 结果是两秒后输出[ 'promise1', 'promise1' ]var promise1=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 2000);});var promise2=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { reject(); }, 0);});Promise.all([promise1,promise2]).then((data)=&gt;{ console.log(data);}).catch(()=&gt;{ console.log(\"promise_all\"); })// promise_allvar promise1=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 2000);});var promise2=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { reject(); }, 1000);}).catch(()=&gt;{ console.log(\"promise_2\");})//这里的promise2实际是catch后返回的新的promise实例Promise.all([promise1,promise2]).then((data)=&gt;{ console.log(data);}).catch(()=&gt;{ console.log(\"promise_all\");})/*输出 promise_2 [ 'promise1', undefined ]为什么呢?因为p2会先reject,reject后被自身的catch捕获，catch会返回新的promise，这个在catch执行完成后会变成resolved,所以最后会调用promise.all的then方法*/ Promise.race 该方法与Promise.all()方法类似，只不过是只要有一个的状态发生改变，新的实例的对象也就会跟着改变。 var promise1=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise1\"); }, 2000);});var promise2=new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { resolve(\"promise2\"); }, 1000);})Promise.race([promise1,promise2]).then((data)=&gt;{ console.log(data);}).catch(()=&gt;{ console.log(\"promise_all\");})//promise2 Promise.resolve 参数是一个Promise对象，将不做任何改变 其他参数，则直接转换，状态为resolved。常用来生成一个状态为fulfilled的promise实例 const p = Promise.resolve('Hello');p.then(function (s){ console.log(s)});// Hello Promise.reject 返回的是一个promise实例，状态是rejected,常用来生成一个状态为rejected的promise实例 const p = Promise.reject('error');//等同于const p = new Promise((resolve, reject) =&gt; reject('error'))p.catch((err)=&gt;{ console.log(err);})//error","link":"/2020/03/12/es6/es6-base-2/"},{"title":"javaScript基础知识(下)","text":"👇内容速览👇 JS的运行机制（浏览器） ES5的继承的实现 浏览器对象与文档对象 JS的运行机制（浏览器） JavaScript是单线程语言，也只能是单线程，因为JS的用途就是与用户交互，假设同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程在删除这个节点，此时浏览器就不知道以哪个线程为准。因此它只有一个调用堆栈（call stack），一次只能做一件事情。例如进入一个函数，则把函数放在堆栈的顶部，如果一个函数返回，则弹出。因为是单线程，所以只能顺序执行，但如果执行的任务耗时间过长，则会产生很多不好的影响，解决这个的方法就是它本身的事件循环机制跟其回调队列。JavaScript 事件循环机制分为浏览器和 Node 事件循环机制。今天先讲浏览器的。 ​ 讲事件循环之前先讲一下浏览器的内核：浏览器内核是多线程，在内核控制下各个线程相互配合保持同步，有以下的常驻线程： GUI渲染线程：负责页面的渲染，解析HTML、 CSS,构建DOM树，布局跟绘制。当界面需要回流重绘的时候就会执行该线程，同时这个线程是跟JS引擎线程互斥的。 JS引擎线程：顾名思义，这个线程是来解析JS代码的，同时也是负责执行需要执行的事件，例如定时器结束、异步成功的回调函数，将依此进入事件队列，等待这个线程的执行。 定时器触发线程：负责执行定时器一类的函数的线程。计数完毕后，事件触发线程就会将计数完毕的事件加入事件队列（这个事件就是触发回调函数的事件），等待JS引擎线程执行。 事件触发线程：负责将准备好的事件交给JS线程执行，例如：定时器函数计数完毕，异步请求成功触发回调函数，用户触发点击事件….. 异步HTTP请求线程:负责异步请求的线程，当异步执行完毕后触发回调函数，事件触发将相应的事件加入任务队列。 事件循环：将执行的任务分成异步跟同步任务。一同步任务跟异步任务进入不同的执行场所。同步进入主线程执行，异步的任务进入Event table 并注册其回调函数。当任务执行完成后，Event table将这个函数移入Event queue（回调队列）——（即在这个队列中放置一个事件）,等到主线程内的任务执行完毕为空，则去Event queue读取相应事件，将对应的函数放入主线程执行。 不断重复，就是事件循环。 “任务队列/回调队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。就是上面事件触发线程跟JS线程之间的交流了。 “任务队列/回调队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 异步任务的区别：但是异步任务来说，应该也有执行的先后吧，有人会这样问。确实，当同时有异步任务一起执行的时候，到底是谁先谁后。这个时候就得说一下宏任务跟微任务了。注：宏任务队列能有多个，微任务队列就只有一个 宏任务：包括整体的同步代码，setTimeout, setInterval，IO ，各种事件等。 微任务：Promise process.nexTick(目前就两个)。 此时事件的循环顺序是，进入整体代码（第一个宏任务）开始第一次循环。遇到宏任务，将其回调函数分发到宏任务Event queue。遇到微任务，将其回调函数分发到微任务Event queue。而后执行这第一个宏任务里面的所有微任务（即执行异步任务的回调队列）。而后再找下一个宏任务，反复循环。🙋‍举个简单的栗子： setTimeout(function() { console.log('setTimeout');})new Promise(function(resolve) { console.log('promise'); resolve();}).then(function() { console.log('then');})console.log('console');//输出结果 promise console then setTimeout/*这段代码作为宏任务，进入主线程。先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。遇到console.log(console)，立即执行。整体代码script作为第一个宏任务执行结束，看看有哪些微任务？发现了then在微任务Event Queue里面，执行。ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。结束。*/ ES5继承的实现JavaScript的继承与其他语言不同，它是通过原型链来实现的。之前已经讲过，一个实例对象的原型(proto)会指向创建这个实例的构造器函数的原型对象(prototype)。当我们访问属性的时候，会先找实例对象本身的属性，如果找不到会往原型链上找。就是通过这种思想来实现继承的。 类式继承：最简单的继承，将父类的实例赋值给子类的原型。缺点是如果父类的属性是引用类型的话，就会出现一些意想不到的情况。(改一个而动全部)。 function Shape(){ this.books=[\"JS\",\"CSS\"];}function TwDshape(){}TwDshape.prototype=new Shape(); TwDshape.prototype.constructor=TwDshape;var my=new TwDshape();var your=new TwDshape();console.log(my.books);// [\"JS\", \"CSS\"]your.books.push(\"HTML\");console.log(my.books);// [\"JS\", \"CSS\", \"HTML\"] 构造函数继承：利用实例对象之间互不影响的特性，将父类的构造器函数在子类构造器函数里面执行一遍，实现继承。缺点是父类的原型对象上的属性不能获取到。因为没有建立原型链。 function Shape(){ this.books=[\"JS\",\"CSS\"];}function TwDshape(){ Shape.call(this);//利用call/apply改变this指向}var my=new TwDshape();var your=new TwDshape();console.log(my.books);// [\"JS\", \"CSS\"]your.books.push(\"HTML\");console.log(my.books);// [\"JS\", \"CSS\"] 寄生组合型继承：构造函数继承与原型的继承的结合（原型对象继承是在类式继承的基础上改进）。结合两种继承方式的优点。 //原型对象继承function inheritObject(parent){ var F=function(){}; //加了一个空中介函数,这样子的好处是直接继承了父级的原型对象的属性 F.prototype=parent.prototype; return new F(); //返回的是空中介函数的实例，不是之前的父类的实例，节省了构造父类实例的步骤}//寄生组合型function Shape(){ this.books=[\"JS\",\"CSS\"];}Shape.prototype.toString=function(){ return this.books; }function TwDshape(){ Shape.call(this);//利用call/apply改变this指向}var p=inheritObject(Shape); //返回的是F实例TwDshape.prototype=p;TwDshape.prototype.constructor=TwDshape; //修正因为重写子类原型对象而导致的constructor被修改var my=new TwDshape();var your=new TwDshape();console.log(my.toString());// [\"JS\", \"CSS\"]your.books.push(\"HTML\");console.log(your.toString());//[\"JS\", \"CSS\", \"HTML\"]console.log(my.toString());// [\"JS\", \"CSS\"] 浏览器对象与文档对象 浏览器对象BOM：页面以外事物拥有的对象。包括window，Navigator,Screen,History, Location。最主要的是window,它包含了对其他几个对象的引用，也有对document对象的引用。 window：浏览器窗口。所有全局 JavaScript 对象，函数和变量自动成为 window 对象的成员。 Navigator：包含了有关访问者的信息。如浏览器应用程序的名称（appName）、是否已启用cookie、浏览器是否在线。 Screen：包含有关客户端显示屏的信息。 History:包含用户访问过的URL。 Location:包含当前有关URL的信息。 DOM：文档对象模型，在HTML DOM中，每个部分都是节点，文挡（document）本身就是文档节点，所有的html元素（element/标签）是元素节点，所有的元素的属性是属性节点，元素的文本是文本节点，注释是注释节点。引用一张图： DOM节点的操作属性跟方法。 1.访问/获取节点document.getElementById(id); //返回对拥有指定id的第一个对象进行访问document.getElementsByName(name); //返回带有指定名称的节点集合 document.getElementsByTagName(tagname); //返回带有指定标签名的对象集合 document.getElementsByClassName(classname); //返回带有指定class名称的对象集合 2.创建节点/属性document.createElement() //创建一个节点document.createAttribute() //对某个节点创建属性document.createTextNode() // 创建文本节点3.添加节点document.inseretBefore(newNode,referenceNode) // 在某个节点前插入节点parentNode.appendChild(newNode) // 给某个节点添加子节点4.复制节点cloneNode（true/false） //复制某个节点5.删除节点parentNode.removeChild（node） // 删除某个节点的子节点6.属性操作getAttribute（name） // 通过属性名称获取某个节点属性的值setAttribute（name,value） // 修改某个节点属性的值removeAttribute（name） //删除某个属性7.查找节点.firstChild // 获取第一个子节点.firstElementChild // 获取第一个元素节点.lastChild // 获取最后一个子节点.lastElementChild // 获取最后一个元素节点.childNodes // 获取节点的所有子节点8.获取相邻的节点.previousSibling //获取已知节点的相邻的上一个节点.previousElementSibling //获取已知节点的相邻的上一个元素节点.nextSibling //获取已知节点的下一个节点.nextElementSibling //获取已知节点的下一个元素节点9.获取父节点.parentNode //得到已知节点的父节点10.替换节点.replace（ newNode，oldNode） //从父节点中用新节点提换旧节点11.修改文本节点appendData（data） //在文本节点后添加节点deleteData（start,length） //从start处删除length字符insertData（start，data） //在start处插入字符，start的开始值是0replaceData（start，length，data）//在start处用data替换length个字符12.nodeName 节点的名称。元素节点的 nodeName 等同于标签名属性节点的 nodeName 是属性名称文本节点的 nodeName 总是 #text文档节点的 nodeName 总是 #document13.nodeValue 节点的值元素节点的 nodeValue 是 null文本节点的 nodeValue 是文本文本属性节点的 nodeValue 是属性值-------------------------------------------------------------------//例子&lt;body&gt; &lt;div id=\"root\"&gt; &lt;a href=\"#\" id=\"a\"&gt;&lt;/a&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; var myTitle = document.getElementById(\"root\").childNodesconsole.log(myTitle)//NodeList(5) [text, a#a, text, p, text] 注：换行在浏览器里面是当成text节点","link":"/2020/03/09/javascript/javaScript-base-2/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"css3","slug":"css3","link":"/tags/css3/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"pattern","slug":"pattern","link":"/categories/pattern/"},{"name":"css3","slug":"css3","link":"/categories/css3/"}]}